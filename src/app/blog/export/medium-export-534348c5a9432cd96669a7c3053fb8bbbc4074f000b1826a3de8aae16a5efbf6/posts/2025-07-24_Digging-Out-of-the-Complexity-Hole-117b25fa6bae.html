<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Digging Out of the Complexity Hole</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Digging Out of the Complexity Hole</h1>
</header>
<section data-field="subtitle" class="p-summary">
June 17–18, 2025
</section>
<section data-field="body" class="e-content">
<section name="f401" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="140f" id="140f" class="graf graf--h3 graf--leading graf--title">Digging Out of the Complexity Hole</h3><p name="6bcf" id="6bcf" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">June 17–18, 2025</em></p><figure name="6605" id="6605" class="graf graf--figure graf--startsWithDoubleQuote graf-after--p"><img class="graf-image" data-image-id="1*kP8ZNMod9j22TQJAhAQHYw.png" data-width="1536" data-height="1024" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*kP8ZNMod9j22TQJAhAQHYw.png"><figcaption class="imageCaption">“Dig up, not down!”</figcaption></figure><p name="0ea0" id="0ea0" class="graf graf--p graf--hasDropCapModel graf--hasDropCap graf--startsWithDoubleQuote graf-after--figure"><span class="graf-dropCap"><span class="graf-dropCapQuote">“</span>I</span> want us digging back <em class="markup--em markup--p-em">out</em> of this hole, not deeper <em class="markup--em markup--p-em">into</em> it.”</p><p name="20b7" id="20b7" class="graf graf--p graf-after--p">That was my plea to Claude halfway through what had started as a simple multi-project support implementation and had somehow devolved into a 30-hour debugging marathon involving duplicate domain models, broken import chains, and the kind of architectural confusion that makes you question everything you thought you knew about your own codebase.</p><p name="badb" id="badb" class="graf graf--p graf-after--p">This is the story of what happens when complexity compounds faster than your ability to manage it, and how systematic recovery sometimes requires admitting you’ve been digging in the wrong direction.</p><h3 name="be3b" id="be3b" class="graf graf--h3 graf-after--p">When simple features aren’t simple</h3><p name="372d" id="372d" class="graf graf--p graf-after--h3">PM-009 was supposed to be straightforward: add multi-project support so users could work with different repositories without manually specifying which one every time. We had patterns established, domain models in place, a test suite written. How hard could it be?</p><p name="e048" id="e048" class="graf graf--p graf-after--p">Famous last words.</p><p name="eade" id="eade" class="graf graf--p graf-after--p">The first sign something was wrong came when our migration script couldn’t figure out which <code class="markup--code markup--p-code">Project</code> class to import. Turns out we&#39;d accidentally created two completely separate model hierarchies: <code class="markup--code markup--p-code">services.domain.models.Project</code> and <code class="markup--code markup--p-code">services.database.models.Project</code>.</p><p name="8695" id="8695" class="graf graf--p graf-after--p">Both were called <code class="markup--code markup--p-code">Project</code>. Both served similar purposes. Neither knew the other existed.</p><h3 name="c3a4" id="c3a4" class="graf graf--h3 graf-after--p">The architectural awakening moment</h3><p name="fcf7" id="fcf7" class="graf graf--p graf--startsWithDoubleQuote graf-after--h3">“Glad I checked. It is already not a good ‘scent’ that we are chasing bugs on this script. It makes me wonder where we were not careful enough to begin with.”</p><p name="e8c0" id="e8c0" class="graf graf--p graf-after--p">That was my moment of recognizing we weren’t dealing with simple bugs — we were dealing with architectural sloppiness that had been accumulating without anyone noticing.</p><p name="3dd3" id="3dd3" class="graf graf--p graf-after--p">Sometimes the most productive thing you can do is stop trying to make broken architecture work and start figuring out why it’s broken in the first place.</p><h3 name="6bb3" id="6bb3" class="graf graf--h3 graf-after--p">When test-driven development meets reality</h3><p name="b02e" id="b02e" class="graf graf--p graf-after--h3">Here’s what made the situation particularly frustrating: we’d been following test-driven development principles religiously for the earlier tickets. Write tests first, implement to pass the tests, refactor carefully. It had worked beautifully through PM-008.</p><p name="6d00" id="6d00" class="graf graf--p graf-after--p">But PM-009 was different. Complex business logic, multi-layer coordination, multiple decision paths. And somewhere in that complexity, we’d abandoned TDD discipline without realizing it.</p><p name="da3b" id="da3b" class="graf graf--p graf-after--p">I should have instructed by assistants to read the test specifications carefully and implemented exactly what the tests expected, but instead they guessed at method names and signatures, and then we spent hours debugging why our <code class="markup--code markup--p-code">llm.infer_project_id()</code> calls didn&#39;t match the <code class="markup--code markup--p-code">llm.complete()</code> methods the tests were mocking</p><p name="643b" id="643b" class="graf graf--p graf-after--p">The tests weren’t wrong. Our implementation was wrong. But we’d been so focused on making the code work that we’d stopped paying attention to what the tests were actually telling us.</p><h3 name="3973" id="3973" class="graf graf--h3 graf-after--p">The duplicate models anti-pattern</h3><p name="51b3" id="51b3" class="graf graf--p graf-after--h3">The root cause of our architectural confusion was hiding in plain sight: we’d created two separate <code class="markup--code markup--p-code">Project</code> classes because an earlier example had shown the structure but not the naming conventions.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="9b2f" id="9b2f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment"># What we accidentally built:</span><br />services.domain.models.Project      <span class="hljs-comment"># Pure business logic</span><br />services.database.models.Project    <span class="hljs-comment"># SQLAlchemy persistence</span><br /><br /><span class="hljs-comment"># What we should have built:</span><br />services.domain.models.Project      <span class="hljs-comment"># Pure business logic  </span><br />services.database.models.ProjectDB  <span class="hljs-comment"># SQLAlchemy persistence</span></span></pre><p name="dd62" id="dd62" class="graf graf--p graf-after--pre">Seems obvious in retrospect, right? But when you’re deep in implementation mode, small naming decisions can have huge architectural consequences.</p><p name="1de5" id="1de5" class="graf graf--p graf-after--p">By the way, usually when I write “we realized” or “we discovered” here, what I really mean is that this was happening in collaboration with Claude as my architectural thinking partner. But the moment of stepping back and saying “wait, why do we have two Project classes?” — that came from forcing myself to slow down and actually look at what we’d built instead of continuing to patch symptoms.</p><h3 name="5a03" id="5a03" class="graf graf--h3 graf-after--p">The cost of violating TDD discipline</h3><p name="e670" id="e670" class="graf graf--p graf-after--h3">The most sobering discovery was realizing how far we’d drifted from test-driven development without noticing.</p><p name="7349" id="7349" class="graf graf--p graf-after--p">Six test failures, all from method signature mismatches. Six opportunities to recognize we weren’t following our own process. And we’d been interpreting each failure as “something’s wrong with the environment” instead of “something’s wrong with our approach.”</p><p name="e0a6" id="e0a6" class="graf graf--p graf-after--p">Complex features don’t need less discipline — they need <em class="markup--em markup--p-em">more</em> discipline. But complexity has a way of making you feel like you don’t have time for proper process.</p><h3 name="520d" id="520d" class="graf graf--h3 graf-after--p">The systematic recovery approach</h3><p name="ca85" id="ca85" class="graf graf--p graf-after--h3">Once we recognized we were digging deeper instead of climbing out, we took a systematic approach to recovery:</p><p name="0b81" id="0b81" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 1: Stop patching symptoms</strong> No more “quick fixes” to make individual tests pass. No more environment tweaks to work around import issues.</p><p name="4d60" id="4d60" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 2: Fix the root architectural problem</strong> Renamed <code class="markup--code markup--p-code">Project</code> → <code class="markup--code markup--p-code">ProjectDB</code> in the database layer, added explicit <code class="markup--code markup--p-code">to_domain()</code> and <code class="markup--code markup--p-code">from_domain()</code> mapping methods.</p><p name="68bc" id="68bc" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 3: Follow the tests exactly</strong> Changed method calls to match what the tests were expecting, not what we thought made sense.</p><p name="5bed" id="5bed" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 4: Verify the foundation</strong> Made sure basic imports and database connections worked before attempting business logic.</p><p name="cc78" id="cc78" class="graf graf--p graf-after--p">The recovery wasn’t glamorous. It was mostly mechanical refactoring and careful attention to details we’d been glossing over. But it worked.</p><h3 name="b1dd" id="b1dd" class="graf graf--h3 graf-after--p">An architectural lesson about examples</h3><p name="4639" id="4639" class="graf graf--p graf-after--h3">One insight from the recovery was how architectural examples can mislead if they’re not complete.</p><p name="c4cf" id="c4cf" class="graf graf--p graf-after--p">We’d been following an example that showed the structure of domain and database models but didn’t specify the naming conventions. So we created two <code class="markup--code markup--p-code">Project</code> classes instead of what we eventually eneded up with, a domain class called <code class="markup--code markup--p-code">Project</code> and database class called <code class="markup--code markup--p-code">ProjectDB</code>.</p><p name="00ac" id="00ac" class="graf graf--p graf-after--p">Good examples don’t just show structure — they show naming, relationships, and boundaries. Incomplete examples can be more dangerous than no examples at all.</p><h3 name="e9bf" id="e9bf" class="graf graf--h3 graf-after--p">Ancknowledging complexity</h3><p name="f32f" id="f32f" class="graf graf--p graf-after--h3">I’ve already made it clear that I find things complex enough as they are and strive to avoid adding any optional complexity, but there comes a time when you need to recognize that some things worth making are by necessity complex.</p><p name="649c" id="649c" class="graf graf--p graf-after--p">Once we were on an even keel. I commented “OK it makes sense that things have gotten harder and more complex. (whew)”</p><p name="52f4" id="52f4" class="graf graf--p graf-after--p">That was my moment of accepting that PM-009 represented a genuine complexity jump from the earlier tickets. Not just more code, but more <em class="markup--em markup--p-em">kinds</em> of complexity:</p><ul class="postList"><li name="460a" id="460a" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Business logic complexity</strong>: Multiple decision paths for project resolution</li><li name="4d09" id="4d09" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Integration complexity</strong>: Coordinating between domain models, repositories, and LLM calls</li><li name="addf" id="addf" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">State management complexity</strong>: Session-based project memory across user interactions</li></ul><p name="6b60" id="6b60" class="graf graf--p graf-after--li">Complexity isn’t a failure — it’s a natural progression as systems grow. But complexity requires acknowledging its presence and adapting your process accordingly.</p><h3 name="e3d7" id="e3d7" class="graf graf--h3 graf-after--p">When architectural refactoring pays off immediately</h3><p name="80fa" id="80fa" class="graf graf--p graf-after--h3">The moment we fixed the duplicate models issue, everything started working. Not “sort of working” or “working with workarounds” — actually working the way it was supposed to.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="0add" id="0add" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment"># After the refactor, imports became obvious:</span><br /><span class="hljs-keyword">from</span> services.domain.models <span class="hljs-keyword">import</span> Project        <span class="hljs-comment"># Business logic</span><br /><span class="hljs-keyword">from</span> services.database.models <span class="hljs-keyword">import</span> ProjectDB    <span class="hljs-comment"># Persistence</span><br /><br /><span class="hljs-comment"># Mapping became explicit:</span><br />project = project_db.to_domain()                  <span class="hljs-comment"># Clean conversion</span><br />project_db = ProjectDB.from_domain(project)       <span class="hljs-comment"># Clear direction</span></span></pre><p name="5adb" id="5adb" class="graf graf--p graf-after--pre">This is what clean architecture gets you: when you fix the foundation, everything else becomes easier.</p><h3 name="adb4" id="adb4" class="graf graf--h3 graf-after--p">The test environment archaeology</h3><p name="2c51" id="2c51" class="graf graf--p graf-after--h3">Part of our debugging odyssey involved figuring out why our test environment had become unstable. The discovery process was like archaeology:</p><ul class="postList"><li name="43d9" id="43d9" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Layer 1</strong>: pytest-asyncio version incompatibility</li><li name="3a52" id="3a52" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Layer 2</strong>: Import path inconsistencies with <code class="markup--code markup--li-code">shared_types</code></li><li name="a605" id="a605" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Layer 3</strong>: NumPy 2.0 compatibility issues in ChromaDB dependencies</li></ul><p name="8203" id="8203" class="graf graf--p graf-after--li"><em class="markup--em markup--p-em">(Oh, NumPy compatibility issues, you numpty! I just can’t quit you.)</em></p><p name="7423" id="7423" class="graf graf--p graf-after--p">Each layer revealed assumptions we’d made about the environment that were no longer true. Each fix revealed the next layer of issues.</p><p name="eee3" id="eee3" class="graf graf--p graf-after--p">Environment issues can mask architectural problems, making you think the problem is with your setup when it’s actually with your code.</p><h3 name="e230" id="e230" class="graf graf--h3 graf-after--p">The multi-AI coordination reality</h3><p name="413a" id="413a" class="graf graf--p graf-after--h3">One surprising aspect of this stage of development was that discovery that even with multiple AI assistants providing review and guidance, we could still all drift into architectural anti-patterns together.</p><ul class="postList"><li name="1187" id="1187" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Claude Opus</strong>: Architecture review and pattern recognition</li><li name="f5e1" id="f5e1" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Claude Sonnet</strong>: Detailed implementation planning</li><li name="9c79" id="9c79" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Cursor Copilot</strong>: Code execution and syntax assistance</li></ul><p name="62b8" id="62b8" class="graf graf--p graf-after--li">Multiple perspectives, multiple checks, and we still ended up with duplicate domain models.</p><p name="69ad" id="69ad" class="graf graf--p graf-after--p">AI collaboration doesn’t eliminate the need for architectural discipline — it just distributes it across more participants.</p><h3 name="b79b" id="b79b" class="graf graf--h3 graf-after--p">The business-logic debugging phase</h3><p name="87e6" id="87e6" class="graf graf--p graf-after--h3">Once we had clean architecture, we could focus on the actual business-logic bugs:</p><ol class="postList"><li name="8ae9" id="8ae9" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Inference vs. last-used logic</strong>: When LLM inference conflicts with session memory</li><li name="6ca3" id="6ca3" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Default project confirmation</strong>: Whether users need to confirm obvious defaults</li><li name="58b0" id="58b0" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Ambiguous project handling</strong>: How to handle “UNCLEAR” responses from LLM</li><li name="78f0" id="78f0" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Missing project errors</strong>: Proper error types for non-existent projects</li></ol><p name="ab70" id="ab70" class="graf graf--p graf-after--li">These were the bugs we <em class="markup--em markup--p-em">should</em> have been debugging from the start. But architectural confusion had made it impossible to isolate business logic issues from infrastructure issues.</p><p name="4977" id="4977" class="graf graf--p graf-after--p">Clean architecture creates clean debugging.</p><h3 name="5f35" id="5f35" class="graf graf--h3 graf-after--p">The 10/16 recovery milestone</h3><p name="d824" id="d824" class="graf graf--p graf--startsWithDoubleQuote graf-after--h3">“10/16 tests passing (major improvement from 2/16)”</p><p name="893f" id="893f" class="graf graf--p graf-after--p">That was our recovery milestone. Not perfect, but systematic progress in the right direction. From nearly complete failure to clear success, with specific remaining issues that had clear solutions.</p><p name="1957" id="1957" class="graf graf--p graf-after--p">Sometimes the most important measure isn’t how many tests are passing — it’s whether you’re making systematic progress or continuing to accumulate problems.</p><h3 name="40af" id="40af" class="graf graf--h3 graf-after--p">Discovering documentation debt</h3><p name="2833" id="2833" class="graf graf--p graf-after--h3">The architectural refactoring revealed that our documentation was describing a system that didn’t match what we’d actually built. Domain models that weren’t properly separated, import patterns that had evolved beyond recognition, test strategies that assumed simpler architecture.</p><p name="d5ce" id="d5ce" class="graf graf--p graf-after--p">We’d made a big effort at documentation, used that to power through the first nine github issues, and along the way forgot to update the docs to capture ongoing decisions and changes. Now they were pretty stale.</p><p name="374c" id="374c" class="graf graf--p graf-after--p">This is how technical debt compounds: inconsistent code leads to inconsistent documentation, which leads to incorrect assumptions in future development.</p><p name="c1f6" id="c1f6" class="graf graf--p graf-after--p">Good documentation isn’t just helpful — it’s a forcing function for architectural clarity.</p><h3 name="9d9b" id="9d9b" class="graf graf--h3 graf-after--p">A lesson about stopping versus pushing through</h3><p name="a54d" id="a54d" class="graf graf--p graf-after--h3">The most important lesson from the complexity hole was about knowing when to stop pushing forward and start digging back.</p><p name="9e79" id="9e79" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Signs you’re pushing forward</strong>: Making progress on intended features, tests passing, clear next steps</p><p name="b925" id="b925" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Signs you’re digging deeper </strong>: Fighting the same issues repeatedly, accumulating workarounds, architectural confusion</p><p name="23f9" id="23f9" class="graf graf--p graf-after--p">The temptation when you’re deep in a complex implementation is to keep pushing until you break through. But sometimes the breakthrough requires changing direction entirely.</p><h3 name="0e61" id="0e61" class="graf graf--h3 graf-after--p">The tension between systematic and tactical</h3><p name="4d9c" id="4d9c" class="graf graf--p graf-after--h3">Throughout the session, there was constant tension between systematic approaches and tactical fixes. Cursor would unfailingly recommend or (even just go ahead and start making!) quick fixes to get the tests to pass, and I had to keep telling it to stop as systematically dug into the root causes.</p><p name="5150" id="5150" class="graf graf--p graf-after--p">Tactical approaches feel faster in the moment. Systematic approaches are faster over time. But when you’re in the middle of complexity, it’s hard to trust that systematic work will pay off.</p><p name="2cda" id="2cda" class="graf graf--p graf-after--p">The recovery proved that systematic approaches work — they just require faith during the implementation.</p><h3 name="1088" id="1088" class="graf graf--h3 graf-after--p">Architectural discipline pays off</h3><p name="dce7" id="dce7" class="graf graf--p graf-after--h3">By the end of the 30-hour session, we had:</p><ul class="postList"><li name="21b6" id="21b6" class="graf graf--li graf-after--p">Clean separation between domain and database models</li><li name="dfa8" id="dfa8" class="graf graf--li graf-after--li">Explicit mapping patterns that prevented future confusion</li><li name="7ffb" id="7ffb" class="graf graf--li graf-after--li">Test environment that worked reliably</li><li name="f182" id="f182" class="graf graf--li graf-after--li">Business logic bugs that were isolated and fixable</li></ul><p name="db4a" id="db4a" class="graf graf--p graf-after--li">None of this was glamorous work. Most of it was cleaning up mistakes we’d made earlier in the session. But it created the foundation for everything that came after.</p><p name="ce19" id="ce19" class="graf graf--p graf-after--p">This recovery work enabled the systematic implementation successes that (spoiler!) were to follow in the next weeks.</p><h3 name="2607" id="2607" class="graf graf--h3 graf-after--p">Managing complexity</h3><p name="59e7" id="59e7" class="graf graf--p graf-after--h3">What I learned from digging out of the complexity hole is that complexity management isn’t about avoiding complexity — it’s about managing it systematically.</p><p name="d1c3" id="d1c3" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Good complexity management</strong>: Acknowledging complexity, adapting process, maintaining discipline</p><p name="2835" id="2835" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Bad complexity management</strong>: Pretending complexity doesn’t exist, abandoning process, accumulating technical debt</p><p name="bcbc" id="bcbc" class="graf graf--p graf-after--p">Complex features require more discipline, not less. But when you’re drowning in complexity, discipline feels like a luxury you can’t afford.</p><h3 name="4b90" id="4b90" class="graf graf--h3 graf-after--p">When recovery becomes learning</h3><p name="2b0e" id="2b0e" class="graf graf--p graf-after--h3">The most unexpected outcome of the complexity hole was how much we learned about our own system architecture. The debugging process forced us to understand relationships and dependencies we’d been taking for granted.</p><p name="ab29" id="ab29" class="graf graf--p graf-after--p">Sometimes you don’t really understand your architecture until you break it and have to fix it systematically.</p><p name="d953" id="d953" class="graf graf--p graf-after--p graf--trailing">Learning to dig out of these complexity holes systematically has enabled us to recognize and address technical debt before it becomes overwhelming.</p></div></div></section><section name="4211" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="fb43" id="fb43" class="graf graf--p graf--leading"><em class="markup--em markup--p-em">Next on Building Piper Morgan: Successful prototype syndrome strikes again.</em></p><p name="d4ae" id="d4ae" class="graf graf--p graf-after--p graf--trailing"><em class="markup--em markup--p-em">What’s your experience with complexity holes? Have you had features that started simple and spiraled into architectural confusion? I’d love to hear about your own “stop digging deeper” moments and what systematic recovery looked like.</em></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@mediajunkie" class="p-author h-card">christian crumlish</a> on <a href="https://medium.com/p/117b25fa6bae"><time class="dt-published" datetime="2025-07-24T12:46:23.774Z">July 24, 2025</time></a>.</p><p><a href="https://medium.com/@mediajunkie/digging-out-of-the-complexity-hole-117b25fa6bae" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 9, 2025.</p></footer></article></body></html>