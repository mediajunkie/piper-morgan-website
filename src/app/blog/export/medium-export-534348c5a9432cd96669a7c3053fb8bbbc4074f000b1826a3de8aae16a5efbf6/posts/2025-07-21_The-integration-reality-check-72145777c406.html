<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>The integration reality check</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">The integration reality check</h1>
</header>
<section data-field="subtitle" class="p-summary">
June 24, 2025
</section>
<section data-field="body" class="e-content">
<section name="2d11" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5186" id="5186" class="graf graf--h3 graf--leading graf--title">The integration reality check</h3><p name="c513" id="c513" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">June 24, 2025</em></p><figure name="899c" id="899c" class="graf graf--figure graf--startsWithDoubleQuote graf-after--p"><img class="graf-image" data-image-id="1*GUqZUzygAHIVvG4mAaVtog.png" data-width="1536" data-height="1024" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*GUqZUzygAHIVvG4mAaVtog.png"><figcaption class="imageCaption">“The head bone connects to the what now?”</figcaption></figure><p name="daac" id="daac" class="graf graf--p graf--hasDropCapModel graf--hasDropCap graf-after--figure"><span class="graf-dropCap">E</span>verything passed unit tests. Nothing worked when I wired it all together.</p><p name="592d" id="592d" class="graf graf--p graf-after--p">This is the humbling reality of integration testing: all your beautiful, isolated components can work perfectly in theory and completely fail when they meet the messy real world of API contracts, field naming conventions, and actual user workflows.</p><p name="1e8a" id="1e8a" class="graf graf--p graf-after--p">But here’s the thing about integration reality checks — they don’t just reveal bugs, they reveal truths about your system that unit tests can’t capture.</p><h3 name="a7f4" id="a7f4" class="graf graf--h3 graf-after--p">The morning of confidence</h3><p name="d4ee" id="d4ee" class="graf graf--p graf-after--h3">The day started well. File upload endpoints were working, conversation handling was solid, and all the pieces seemed ready to connect. Time for the big moment: fire up the web interface (that’s what we were supposed to be making work after all), upload a file, ask Piper to summarize or analyze it in chat, watch the magic happen.</p><p name="85e3" id="85e3" class="graf graf--p graf-after--p">Spoiler alert: no magic happened.</p><h3 name="e9fe" id="e9fe" class="graf graf--h3 graf-after--p">Field-naming chaos</h3><p name="a9c6" id="a9c6" class="graf graf--p graf-after--h3">First problem: the frontend expected a <code class="markup--code markup--p-code">response</code> field, the backend was sending <code class="markup--code markup--p-code">message</code>. Classic integration mismatch that no unit test catches because each side works perfectly within its own assumptions.</p><p name="69fc" id="69fc" class="graf graf--p graf-after--p">Also, a bad sign that along the way we were not checking what had already been built. Whenever I find a bug like this I am reminded that I allowed an AI assistant to write code without checking what was already written, which leads to… well, you can’t call it hallucination in this case, but let’s just call it “making stuff up.”</p><p name="94ee" id="94ee" class="graf graf--p graf-after--p">Another example: the frontend called <code class="markup--code markup--p-code">/api/v1/knowledge/upload</code>, but the backend had <code class="markup--code markup--p-code">/api/v1/files/upload</code>. There were other random (if plausible) field mismatches: <code class="markup--code markup--p-code">document_id</code> vs <code class="markup--code markup--p-code">file_id</code>. The kind of inconsistencies that accumulate when you&#39;re building too fast and not sweating the details.</p><h3 name="23b6" id="23b6" class="graf graf--h3 graf-after--p">The LLM-provider plot twist</h3><p name="7e5e" id="7e5e" class="graf graf--p graf-after--h3">Just as things started working, I hit Anthropic’s API credit limit. In production. During testing. This led to a bit of misdirected debugging till I looked more closely at the terminal outfit, which included an email address to contact if I wanted them to up my quota.</p><p name="967c" id="967c" class="graf graf--p graf-after--p">So, weturned this into a feature by implementing automatic LLM provider fallback (Anthropic → OpenAI), along the way discovering enum mismatches (<code class="markup--code markup--p-code">GPT4_TURBO</code> vs <code class="markup--code markup--p-code">GPT4</code>) that would have been painful to debug later. Sometimes constraints force you to build better architecture!</p><h3 name="76a1" id="76a1" class="graf graf--h3 graf-after--p">Python compatibility strikes again</h3><p name="f61d" id="f61d" class="graf graf--p graf-after--h3">Remember asyncio.timeout()? <em class="markup--em markup--p-em">Noooo! Ay-sink-ee-oh! </em>Turns out it doesn’t exist in Python 3.9. So the orchestration engine that worked perfectly in development broke immediately in the testing environment.</p><p name="4a75" id="4a75" class="graf graf--p graf-after--p">The fix was simple enough (<code class="markup--code markup--p-code">asyncio.wait_for()</code> everywhere), but it reinforced something important: integration testing catches environment assumptions that unit tests never see.</p><h3 name="bda2" id="bda2" class="graf graf--h3 graf-after--p">The workflow mapping mystery</h3><p name="25e7" id="25e7" class="graf graf--p graf-after--h3">My favorite integration bug: OpenAI correctly identified the <code class="markup--code markup--p-code">analyze_file</code> intent, but the workflow factory had no mapping for it. The AI understood what the user wanted, but the system didn&#39;t know how to execute it. This wouldn’t be the last time I started testing something Claude told me was complete only to find just the first layer built or nothing connected.</p><p name="7683" id="7683" class="graf graf--p graf-after--p">One line fix: <code class="markup--code markup--p-code">&#39;analyze_file&#39;: WorkflowType.ANALYZE_FILE</code>. But it revealed how easy it is for different parts of the system to evolve at different rates.</p><h3 name="ea0c" id="ea0c" class="graf graf--h3 graf-after--p">UI polling madness</h3><p name="34b3" id="34b3" class="graf graf--p graf-after--h3">The status checks were uppercase (<code class="markup--code markup--p-code">COMPLETED</code>) but the backend sent lowercase. So the UI kept polling forever, convinced the workflow was still running when it had finished minutes ago.</p><p name="1b9d" id="1b9d" class="graf graf--p graf-after--p">These aren’t bugs exactly — they’re integration contract mismatches. Each component worked correctly within its own understanding of the world. It’s a tricky concept to wrap your head around. Every piece you built works and passes its own tests in isolation, but when you put them together it fails. It’s like going from atoms to molecules to organs to a body. You need to make sure every level if working.</p><p name="22c4" id="22c4" class="graf graf--p graf-after--p">Any these mismatches around things like capitalization conventions were another sign we were not yet disciplining the process in a way that respected past work.</p><h3 name="6bca" id="6bca" class="graf graf--h3 graf-after--p">When it all clicked</h3><p name="f632" id="f632" class="graf graf--p graf-after--h3">After fixing the field mismatches, adding LLM fallbacks, updating the Python compatibility, mapping the workflows, and synchronizing the case conventions, something beautiful happened: the complete file analysis slice worked end-to-end.</p><p name="f517" id="f517" class="graf graf--p graf-after--p">User uploads file → references it naturally → system resolves, creates workflow, executes analysis → UI shows success. The whole vertical slice, working as intended.</p><p name="f3ad" id="f3ad" class="graf graf--p graf-after--p">(Well, almost. The analysis was still just a placeholder returning “success” without actually reading files. But the integration points were solid.)</p><h3 name="9631" id="9631" class="graf graf--h3 graf-after--p">What integration testing taught me</h3><p name="7d1a" id="7d1a" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">Unit tests are necessary but not sufficient.</strong> They validate individual component behavior but can’t catch contract mismatches, environment assumptions, or protocol violations.</p><p name="8328" id="8328" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Integration failures compound.</strong> One field naming issue becomes three API mismatches becomes five UI bugs. Fix the pattern, not just the instance.</p><p name="4e31" id="4e31" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Resilience through fallbacks.</strong> The LLM provider switching saved the session and revealed a better architecture. Build expecting failures.</p><p name="d71e" id="d71e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Real data reveals real problems.</strong> Mock implementations can hide issues that only surface with actual API calls, real file uploads, and genuine user workflows.</p><h3 name="6be4" id="6be4" class="graf graf--h3 graf-after--p">The architectural insight</h3><p name="3853" id="3853" class="graf graf--p graf-after--h3">Integration testing isn’t just debugging — it’s architectural validation. Every mismatch reveals an assumption that needs to be made explicit. Every fallback reveals a dependency that needs to be managed.</p><p name="f286" id="f286" class="graf graf--p graf-after--p">The gaps between components aren’t bugs to be fixed, they’re design decisions to be made consciously. Making them ahead of time can save a lot of grief, I am gradually discovering.</p><p name="b22e" id="b22e" class="graf graf--p graf-after--p">We see this pattern beyond the code level as well. Building a product involves more than integrating modules into coherent functional workflows. You also have to integrate user feedback, what the market is telling you, and more.</p><h3 name="8dee" id="8dee" class="graf graf--h3 graf-after--p">What’s next</h3><p name="fd12" id="fd12" class="graf graf--p graf-after--h3">With the integration points working and fallbacks in place, we were finally ready to implement actual file reading and analysis logic. The foundation proved it can handle real workflows under real constraints.</p><p name="be02" id="be02" class="graf graf--p graf-after--p graf--trailing">But first: more integration tests. Because if there’s one thing this taught me, it’s that the gaps between the pieces are where the interesting problems hide.</p></div></div></section><section name="fd74" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="0929" id="0929" class="graf graf--p graf--leading"><em class="markup--em markup--p-em">Next on Building Piper Morgan: “When TDD Saves Your Architecture” — How 34 tests and zero compromises built unshakeable foundations.</em></p><p name="cd68" id="cd68" class="graf graf--p graf-after--p graf--trailing"><em class="markup--em markup--p-em">Ever had that moment when everything works in isolation but nothing works together? I’d love to hear how others approach the integration reality check in their own projects.</em></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@mediajunkie" class="p-author h-card">christian crumlish</a> on <a href="https://medium.com/p/72145777c406"><time class="dt-published" datetime="2025-07-21T12:46:41.049Z">July 21, 2025</time></a>.</p><p><a href="https://medium.com/@mediajunkie/the-integration-reality-check-72145777c406" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 9, 2025.</p></footer></article></body></html>