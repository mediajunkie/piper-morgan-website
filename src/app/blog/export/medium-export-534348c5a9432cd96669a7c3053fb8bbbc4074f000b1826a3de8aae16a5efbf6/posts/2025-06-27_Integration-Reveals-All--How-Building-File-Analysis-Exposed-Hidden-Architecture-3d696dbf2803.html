<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Integration Reveals All: How Building File Analysis Exposed Hidden Architecture</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Integration Reveals All: How Building File Analysis Exposed Hidden Architecture</h1>
</header>
<section data-field="subtitle" class="p-summary">
June 27, 2025
</section>
<section data-field="body" class="e-content">
<section name="26e6" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="bbf6" id="bbf6" class="graf graf--h3 graf--leading graf--title">Integration Reveals All: How Building File Analysis Exposed Hidden Architecture</h3><p name="054e" id="054e" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">June 27, 2025</em></p><figure name="a5b5" id="a5b5" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*lYch5pWcEjOBd0SsQYFWOw.png" data-width="1536" data-height="1024" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*lYch5pWcEjOBd0SsQYFWOw.png"><figcaption class="imageCaption">How far down does it go?</figcaption></figure><p name="4858" id="4858" class="graf graf--p graf--hasDropCapModel graf--hasDropCap graf-after--figure"><span class="graf-dropCap">W</span>hen we started PM-011 — adding file upload to our AI PM assistant — it seemed straightforward (and by we I mean me, Claude Opus, Claude Sonnet, and Cursor Agent). Users should be able to upload a CSV or PDF and ask questions about it. “Just add a file picker and wire it to the LLM,” I thought.</p><p name="1746" id="1746" class="graf graf--p graf-after--p">One week later, we’d built a file analysis system with type detection, domain-specific analyzers, and comprehensive error handling. More importantly, we’d discovered something experienced programmes and technical architects no doubt already knew: a<strong class="markup--strong markup--p-strong">rchitectural inconsistencies love to hide between systems, and integration is where they throw their surprise party.</strong></p><h3 name="1319" id="1319" class="graf graf--h3 graf-after--p">Domain models are sacred (no, really!)</h3><p name="882d" id="882d" class="graf graf--p graf-after--h3">The first critical lesson came when we were implementing file analyzers. We had a domain model for <code class="markup--code markup--p-code">AnalysisResult</code> that looked like this:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="709f" id="709f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">@dataclass</span><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnalysisResult</span>:<br />    file_id: <span class="hljs-built_in">str</span><br />    analysis_type: AnalysisType<br />    summary: <span class="hljs-built_in">str</span><br />    key_findings: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]<br />    metadata: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]<br />    recommendations: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]<br />    generated_at: datetime</span></pre><p name="f6a2" id="f6a2" class="graf graf--p graf-after--pre">When we started testing the DocumentAnalyzer, we discovered it was storing extracted information in <code class="markup--code markup--p-code">metadata[&#39;key_points&#39;]</code> rather than the <code class="markup--code markup--p-code">key_findings</code> field. The temptation was obvious: modify the domain model to have a <code class="markup--code markup--p-code">key_points</code> field to make the test pass.</p><p name="3f5d" id="3f5d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">This would have been architectural poison.</strong></p><p name="ae16" id="ae16" class="graf graf--p graf-after--p">Instead, we established a non-negotiable principle handed down from our chief architect when I asked how to build Piper Morgan the right way: <strong class="markup--strong markup--p-strong">Domain models are the contract. Implementation serves the domain, not vice versa.</strong> If a test expects different structure than the domain model provides, fix the test or the implementation — never the domain model.</p><p name="441d" id="441d" class="graf graf--p graf-after--p">This isn’t revolutionary thinking — it’s just applying Eric Evans’ DDD (domain-driven design) principles to AI systems. But here’s what’s interesting: with AI outputs being inherently unpredictable, domain consistency becomes even more critical. <strong class="markup--strong markup--p-strong">You’re essentially building a normalizing layer between chaos and your application.</strong></p><p name="bbcc" id="bbcc" class="graf graf--p graf-after--p">This discipline paid dividends throughout the project. When we integrated multiple analyzers, they all conformed to the same contract. When we added error handling, we used the metadata field consistently. When we built the orchestration layer, it could handle all analysis types uniformly.</p><p name="9acb" id="9acb" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Key Insight</strong>: In AI systems, domain consistency is even more critical because you’re dealing with unpredictable outputs that need to be normalized into reliable structures.</p><h3 name="953d" id="953d" class="graf graf--h3 graf-after--p">Error handling as a design principle (not an afterthought)</h3><p name="f95f" id="f95f" class="graf graf--p graf-after--h3">Traditional software fails predictably — null references, type mismatches, network timeouts. AI systems fail creatively. Files might be corrupted in novel ways, LLMs might return unexpected formats, or analysis might succeed partially.</p><p name="30d5" id="30d5" class="graf graf--p graf-after--p">When working on a natural language chatbot at a mental health startup, we had to worry even more about how error conditions might lead to irregular and distressing communications!</p><p name="8992" id="8992" class="graf graf--p graf-after--p">What I learned building Piper Morgan is to design error handling as a first-class architectural concern:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="275f" id="275f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment"># WRONG: Let exceptions bubble up inconsistently</span><br /><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">analyze_document</span>(<span class="hljs-params">self, file_path: <span class="hljs-built_in">str</span></span>) -&gt; AnalysisResult:<br />    content = extract_text(file_path)  <span class="hljs-comment"># Might throw</span><br />    summary = self.llm_client.summarize(content)  <span class="hljs-comment"># Might fail</span><br />    <span class="hljs-keyword">return</span> AnalysisResult(summary=summary, ...)<br /><br /><span class="hljs-comment"># RIGHT: Consistent error handling with informative metadata</span><br /><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">analyze_document</span>(<span class="hljs-params">self, file_path: <span class="hljs-built_in">str</span></span>) -&gt; AnalysisResult:<br />    <span class="hljs-keyword">try</span>:<br />        content = extract_text(file_path)<br />        summary = self.llm_client.summarize(content)<br />        <span class="hljs-keyword">return</span> AnalysisResult(<br />            summary=summary,<br />            key_findings=key_points,<br />            metadata={<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-string">&quot;content_length&quot;</span>: <span class="hljs-built_in">len</span>(content)}<br />        )<br />    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br />        <span class="hljs-keyword">return</span> AnalysisResult(<br />            summary=<span class="hljs-string">&quot;Analysis failed&quot;</span>,<br />            key_findings=[],<br />            metadata={<br />                <span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-built_in">str</span>(e),<br />                <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;failed&quot;</span>,<br />                <span class="hljs-string">&quot;failure_stage&quot;</span>: <span class="hljs-string">&quot;text_extraction&quot;</span><br />            }<br />        )</span></pre><p name="0bfb" id="0bfb" class="graf graf--p graf-after--pre">This pattern — always return a result object with error information in metadata — enabled sophisticated error recovery. The orchestration layer could provide partial results, explain what went wrong, and suggest next steps.</p><h3 name="763b" id="763b" class="graf graf--h3 graf-after--p">Test-driven development with AI assistance</h3><p name="0e43" id="0e43" class="graf graf--p graf-after--h3">Building with AI assistance, we discovered that TDD requires extra discipline. The AI can generate impressive code that passes tests, but it can also generate tests that accommodate broken implementations.</p><p name="d4ad" id="d4ad" class="graf graf--p graf-after--p">I’ve been getting implementation guidance from Claude and then using Cursor Agent to edit files and run tests without my usual typo-prone, indentation-deprived mistakes that add hours to debugging. Unfortunately, CA (as I’ve come to think of it) is always a bit too eager and the moment a test fails, it offers to <em class="markup--em markup--p-em">edit the test</em> so it will pass.</p><p name="2200" id="2200" class="graf graf--p graf-after--p">This is anathema and it even claims to be aware that we are doing TDD! I have learned to ask Claude to write prompts for CA for me that box it in and strictly tell it to report back and not start hacking away to chase bugs or editing tests willy-nilly</p><p name="65c6" id="65c6" class="graf graf--p graf-after--p">We established strict TDD discipline:</p><ol class="postList"><li name="c2bd" id="c2bd" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Write tests that reflect the domain contract first</strong></li><li name="d531" id="d531" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Verify tests fail for the right reasons</strong></li><li name="6662" id="6662" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Implement minimal code to pass tests</strong></li><li name="4b59" id="4b59" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Refactor while maintaining test integrity</strong></li></ol><p name="1bf9" id="1bf9" class="graf graf--p graf-after--li">The critical insight: <strong class="markup--strong markup--p-strong">When tests fail, don’t change the test unless the domain contract is wrong.</strong></p><p name="9931" id="9931" class="graf graf--p graf-after--p">During DocumentAnalyzer implementation, we had two failing tests that expected the analyzer to throw exceptions. But our established pattern was to return results with error metadata. The failing tests weren’t indicating missing implementation — they were documenting an obsolete contract that needed updating.</p><p name="7b13" id="7b13" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">AI assistance makes it easy to “fix” tests by changing expectations rather than implementation. Resist this temptation.</strong></p><h3 name="01ec" id="01ec" class="graf graf--h3 graf-after--p">Architecture emerges from integration (surprise!)</h3><p name="5325" id="5325" class="graf graf--p graf-after--h3">OK, this is where it gets interesting. The most revealing architectural discoveries came not from planning but from trying to make components work together.</p><p name="1e66" id="1e66" class="graf graf--p graf-after--p">When implementing file resolution (matching “analyze the uploaded spreadsheet” to specific files), we discovered we had two separate orchestration systems:</p><ul class="postList"><li name="3e6e" id="3e6e" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">WorkflowExecutor</strong>: Legacy prototype code from initial GitHub integration</li><li name="9db5" id="9db5" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">OrchestrationEngine</strong>: Canonical task-based architecture per our design docs</li></ul><p name="2a6c" id="2a6c" class="graf graf--p graf-after--li">This duplication was invisible until integration forced us to choose. Classic. Not unlike the way we frequently stumble on parallel government systems doing almost the exact same thing.</p><p name="04be" id="04be" class="graf graf--p graf-after--p">But here’s the twist: What looked like technical debt was actually intentional architectural separation:</p><ul class="postList"><li name="3754" id="3754" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">AsyncPG database</strong>: For operational entities (files, workflows) requiring performance</li><li name="aa57" id="aa57" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">SQLAlchemy ORM</strong>: For domain entities (projects, features) needing rich relationships</li></ul><p name="3889" id="3889" class="graf graf--p graf-after--li">Sometimes “technical debt” is actually undocumented architectural decisions. Who knew? (Everyone who’s maintained legacy systems, that’s who.)</p><h3 name="e93e" id="e93e" class="graf graf--h3 graf-after--p">Building feedback loops from day one</h3><p name="407e" id="407e" class="graf graf--p graf-after--h3">The most important architectural decision wasn’t about code — it was about learning. Every analysis result includes metadata that enables improvement:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="5036" id="5036" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">metadata = {<br />    <span class="hljs-string">&quot;confidence_score&quot;</span>: <span class="hljs-number">0.85</span>,<br />    <span class="hljs-string">&quot;analysis_duration&quot;</span>: <span class="hljs-number">2.3</span>,<br />    <span class="hljs-string">&quot;llm_tokens_used&quot;</span>: <span class="hljs-number">1247</span>,<br />    <span class="hljs-string">&quot;user_corrections&quot;</span>: [],<br />    <span class="hljs-string">&quot;improvement_suggestions&quot;</span>: []<br />}</span></pre><p name="6fd9" id="6fd9" class="graf graf--p graf-after--pre">This metadata serves multiple purposes:</p><ul class="postList"><li name="a043" id="a043" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Quality Assessment</strong>: Track which analyses are most/least reliable</li><li name="191f" id="191f" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Performance Monitoring</strong>: Identify bottlenecks and optimize accordingly</li><li name="dc24" id="dc24" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Learning Data</strong>: Capture user corrections for future model improvements</li><li name="ee88" id="ee88" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Debugging Context</strong>: Understand failures with complete context</li></ul><p name="8689" id="8689" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Critical Insight</strong>: AI systems aren’t just software that works — they’re software that learns. Building learning mechanisms after the fact is much harder than designing them in from the beginning.</p><p name="924d" id="924d" class="graf graf--p graf-after--p">Really, this is just good instrumentation. The difference is that with AI systems, the instrumentation becomes training data.</p><h3 name="0767" id="0767" class="graf graf--h3 graf-after--p">Vertical slices reveal truth</h3><p name="13a5" id="13a5" class="graf graf--p graf-after--h3">Our biggest breakthrough came from testing complete user journeys rather than individual components. We called this “vertical slice development” — implementing the thinnest possible end-to-end feature and then expanding. (The vertical slice concept seems to have arisen in the early agile/XP days, but I still haven’t tracked down where the metaphor of falling through a series of holes in swiss cheese came from, though “swiss cheeseholes” quickly became a shorthand in our chats.)</p><p name="55a5" id="55a5" class="graf graf--p graf-after--p">The vertical slice for file analysis was: upload CSV → detect type → analyze → return results. This simple journey revealed:</p><ul class="postList"><li name="2926" id="2926" class="graf graf--li graf-after--p">File resolution needed confidence scoring for ambiguity (“analyze the spreadsheet” when multiple CSVs exist)</li><li name="1dab" id="1dab" class="graf graf--li graf-after--li">Type detection couldn’t just check file extensions</li><li name="43bc" id="43bc" class="graf graf--li graf-after--li">We had duplicate orchestration systems (oops)</li><li name="64c8" id="64c8" class="graf graf--li graf-after--li">Some “technical debt” was intentional separation (double oops)</li></ul><p name="e92e" id="e92e" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">None of these requirements were visible when building components in isolation.</strong></p><p name="cb31" id="cb31" class="graf graf--p graf-after--p">Building horizontally (all file types, then all analyzers, then all integrations) would have missed these insights until much later in development.</p><h3 name="88b3" id="88b3" class="graf graf--h3 graf-after--p">Domain-first AI architecture (AI is “just another service”)</h3><p name="324b" id="324b" class="graf graf--p graf-after--h3">The overarching lesson: <strong class="markup--strong markup--p-strong">successful AI systems are domain-driven systems that happen to use AI, not AI systems that happen to solve domain problems (</strong>just applying what we learned from the microservices hype cycle to the AI hype cycle)<strong class="markup--strong markup--p-strong">.</strong></p><p name="f888" id="f888" class="graf graf--p graf-after--p">Our file analysis system works because:</p><ul class="postList"><li name="171f" id="171f" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Domain models define clear contracts</strong> that AI outputs must conform to</li><li name="444e" id="444e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Business logic lives in services</strong>, not in prompt engineering</li><li name="7788" id="7788" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Error handling follows established patterns</strong>, making the system predictable</li><li name="0405" id="0405" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Integration points are explicit</strong>, making the system composable</li><li name="eecf" id="eecf" class="graf graf--li graf-after--li">The AI provides <strong class="markup--strong markup--li-strong">intelligence within structure</strong></li></ul><p name="f8b1" id="f8b1" class="graf graf--p graf-after--li">The AI is basically a really clever but somewhat chaotic service in our architecture. No more magical than a database or message queue — just different failure modes.</p><h3 name="b330" id="b330" class="graf graf--h3 graf-after--p">What this means for your AI projects</h3><ol class="postList"><li name="4bb6" id="4bb6" class="graf graf--li graf-after--h3"><strong class="markup--strong markup--li-strong">Design domain models first</strong> — The AI will thank you later (well, not literally)</li><li name="c860" id="c860" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Treat AI like any external service</strong> — Validate outputs, handle errors, monitor performance</li><li name="56d4" id="56d4" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Build feedback loops early</strong> — Not because it’s “AI best practice” but because it’s good engineering</li><li name="5086" id="5086" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Use vertical slices </strong>— Integration reveals truth faster than isolated components</li><li name="35ff" id="35ff" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Maintain architectural discipline</strong> even when AI assistance makes shortcuts tempting: resist</li></ol><h3 name="413f" id="413f" class="graf graf--h3 graf-after--li">The Path Forward</h3><p name="5785" id="5785" class="graf graf--p graf-after--h3">A week ago, “analyze this file” was a nice-to-have feature. Today, it’s a sophisticated system that can intelligently process CSV data, extract insights from PDFs, understand document structure, handle errors gracefully, and learn from user feedback.</p><p name="a3ca" id="a3ca" class="graf graf--p graf-after--p">More importantly, we’ve established patterns for building AI capabilities that integrate cleanly with traditional software architecture. The next features — document ingestion, GitHub analysis, workflow automation — can build on this foundation rather than starting from scratch.</p><p name="c708" id="c708" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">The ultimate insight</strong>: Building AI products isn’t about having the smartest models. It’s about creating systems that make AI capabilities reliable, predictable, and composable.</p><p name="c5fa" id="c5fa" class="graf graf--p graf-after--p">Building AI products isn’t about having the smartest models. It’s about creating systems that make AI capabilities reliable, predictable, and composable. That requires the same architectural discipline we’ve always needed — just with weirder bugs.</p><p name="3535" id="3535" class="graf graf--p graf-after--p graf--trailing">It remains to be seen how some of these trusted patterns will hold up as the software models continue to evolve but I find it interesting right now that the practices most needed to develop reliable LLM-powered systems are more or less just today’s best practices for robust, well-architected software, occasionally stretched to accommodate this strange new world we’re in.</p></div></div></section><section name="f23c" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="be74" id="be74" class="graf graf--p graf--leading graf--trailing"><em class="markup--em markup--p-em">This journey from simple file upload to intelligent analysis system demonstrates how domain-driven design principles enable sophisticated AI capabilities while maintaining architectural integrity. The key is treating AI as a powerful capability within a well-designed system, not as a replacement for good system design.</em></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@mediajunkie" class="p-author h-card">christian crumlish</a> on <a href="https://medium.com/p/3d696dbf2803"><time class="dt-published" datetime="2025-06-27T13:29:26.570Z">June 27, 2025</time></a>.</p><p><a href="https://medium.com/@mediajunkie/integration-reveals-all-how-building-file-analysis-exposed-hidden-architecture-3d696dbf2803" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 9, 2025.</p></footer></article></body></html>