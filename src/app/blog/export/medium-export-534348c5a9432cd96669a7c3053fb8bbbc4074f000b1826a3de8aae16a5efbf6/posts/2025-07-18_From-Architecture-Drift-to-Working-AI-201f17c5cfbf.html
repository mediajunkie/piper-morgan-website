<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>From Architecture Drift to Working AI</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">From Architecture Drift to Working AI</h1>
</header>
<section data-field="subtitle" class="p-summary">
June 15, 2025
</section>
<section data-field="body" class="e-content">
<section name="5efb" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="e59e" id="e59e" class="graf graf--h3 graf--leading graf--title">From Architecture Drift to Working AI</h3><p name="67c5" id="67c5" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">June 15, 2025</em></p><figure name="e5d5" id="e5d5" class="graf graf--figure graf--startsWithDoubleQuote graf-after--p"><img class="graf-image" data-image-id="1*EjxBdBIXlbW6XbWmGLFJPA.png" data-width="1536" data-height="1024" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*EjxBdBIXlbW6XbWmGLFJPA.png"><figcaption class="imageCaption">“Get back on track!”</figcaption></figure><p name="b1d5" id="b1d5" class="graf graf--p graf--hasDropCapModel graf--hasDropCap graf-after--figure"><span class="graf-dropCap">W</span>ell, I thought I was just going to connect some dots. Finish PM-008, get GitHub issue analysis working end-to-end, maybe record a demo for the team. You know, a nice straightforward Friday afternoon of development.</p><p name="25d4" id="25d4" class="graf graf--p graf-after--p">Three hours later I’m knee-deep in what you might call “architectural archaeology” — digging through layers of implementation decisions to figure out why we had three different Task classes that couldn’t talk to each other.</p><p name="d807" id="d807" class="graf graf--p graf-after--p">(By the way, every time I say “we realized” or “we discovered” in this post, it really means Claude proposed something and I tried to keep up with the implications while juggling Docker conflicts.)</p><h3 name="0cee" id="0cee" class="graf graf--h3 graf-after--p">The goal was simple enough</h3><p name="91d7" id="91d7" class="graf graf--p graf-after--h3">PM-008 was supposed to be our first complete AI workflow: GitHub issue analysis from start to finish. The intent classification worked fine, the GitHub integration existed, but that crucial middle layer — workflow execution — was completely broken. Tasks got created but never executed, workflows existed in theory but couldn’t persist, and error messages were about as helpful as a snooty barista.</p><p name="7e1c" id="7e1c" class="graf graf--p graf-after--p">What looked like a simple “connect the dots” problem turned out to be fundamental architectural inconsistencies threatening the entire system’s integrity.</p><h3 name="62ad" id="62ad" class="graf graf--h3 graf-after--p">Meanwhile, back in environment hell</h3><p name="be99" id="be99" class="graf graf--p graf-after--h3">Before we could even start debugging, I had to deal with the practical reality of developing across multiple machines without losing momentum to environment setup. Docker conflicts, PostgreSQL connection failures, and the classic “worked yesterday, broken today” syndrome that every developer knows by heart.</p><p name="1881" id="1881" class="graf graf--p graf-after--p">Mind you, this isn’t just about Docker containers — it’s about session startup protocols that account for port conflicts, service dependencies, and the fact that Homebrew PostgreSQL likes to claim port 5432 before Docker gets a chance. (If you’ve ever wondered why your local development setup works perfectly until you restart your laptop, this is why.)</p><p name="ab3f" id="ab3f" class="graf graf--p graf-after--p">The seemingly mundane work of getting consistent environments reinforced something important: architecture decisions must account for operational reality, not just logical design.</p><h3 name="de30" id="de30" class="graf graf--h3 graf-after--p">Catching ourselves freelancing</h3><p name="3139" id="3139" class="graf graf--p graf-after--h3">The breakthrough moment came when I pointed out to Claude that at some point we’d started “freelancing” — making implementation decisions without consulting our own design specifications. The symptom was simple enough: <code class="markup--code markup--p-code">&#39;Workflow&#39; object has no attribute &#39;get_next_task&#39;</code>. The root cause was architectural drift.</p><p name="d966" id="d966" class="graf graf--p graf-after--p">We had inadvertently created three different Task classes:</p><ul class="postList"><li name="3109" id="3109" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">services.domain.models.Task</code> (domain business logic)</li><li name="d854" id="d854" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">services.orchestration.tasks.Task</code> (orchestration-specific)</li><li name="eb1f" id="eb1f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">services.database.models.Task</code> (persistence layer)</li></ul><p name="5d5b" id="5d5b" class="graf graf--p graf-after--li">Each served a purpose, but they weren’t aligned. The workflow factory created domain Tasks, the engine expected orchestration Tasks, and the database used its own Task model. No wonder task execution was failing.</p><p name="9ee4" id="9ee4" class="graf graf--p graf-after--p">(This is what happens when you’re building a PM assistant without following your own PM methodology — you get to debug your architectural decisions in real time.)</p><h3 name="59e3" id="59e3" class="graf graf--h3 graf-after--p">Domain-first design saves the day</h3><p name="3b6b" id="3b6b" class="graf graf--p graf-after--h3">When we actually returned to our technical specifications — imagine that, reading our own docs — the guidance was clear: domain objects should drive technical decisions, not the other way around. PM concepts like workflows and tasks should be first-class entities with business logic, not just data structures.</p><p name="16c6" id="16c6" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Tech geezer flashback: I’m pretty sure I first heard about DDD from Kent Beck, in the previous, um, millennium?</em></p><p name="f6f9" id="f6f9" class="graf graf--p graf-after--p">Instead of patching individual symptoms, we methodically aligned the implementation with the original design. Enhanced the domain Task class with proper types and business methods, fixed the workflow factory to create domain objects with correct relationships, completely rewrote the orchestration engine to use domain-first patterns.</p><p name="a819" id="a819" class="graf graf--p graf-after--p">The key was working through each layer systematically, checking our specs before making assumptions, and applying the repository pattern to cleanly separate domain logic from persistence concerns.</p><h3 name="2b8e" id="2b8e" class="graf graf--h3 graf-after--p">When persistence actually works</h3><p name="83d6" id="83d6" class="graf graf--p graf-after--h3">Getting database persistence working revealed another architectural win. Rather than tightly coupling workflow execution to database models, we implemented clean domain-to-database conversion through repositories. Domain workflows with business logic methods persist to database models optimized for storage, with clear boundaries between layers.</p><p name="b67e" id="b67e" class="graf graf--p graf-after--p">This pattern proved its worth immediately: when we needed to add workflow state tracking, the changes were isolated to the repository layer. The domain logic stayed clean, and the database schema could evolve independently.</p><p name="d7aa" id="d7aa" class="graf graf--p graf-after--p">Thinking about when I was directing product on the last iteration of AOL Instant Messenger (AIM), and the spaghetti that had accumulated there. We had more QA engineers that regular engineers! The hours we could have saved with that sort of architectural hygiene… but you can’t retrofit that sort of thing. If you don’t get it right from the start, it’s just about impossible.</p><h3 name="1fe2" id="1fe2" class="graf graf--h3 graf-after--p">Real AI in action</h3><p name="e495" id="e495" class="graf graf--p graf-after--h3">After fixing the architectural foundation, PM-008 came alive. The system now extracts GitHub URLs from natural language requests, fetches real issues via API, applies 85 documents of PM knowledge for context-aware analysis, and generates professional improvement suggestions with confidence scoring.</p><p name="be34" id="be34" class="graf graf--p graf-after--p">Testing with “Disabling the gutter icon by default”, the system correctly identified the issue’s vagueness, suggested specific improvements, and provided actionable feedback — all while applying PM best practices from the knowledge base.</p><h3 name="f878" id="f878" class="graf graf--h3 graf-after--p">Nevertheless, we persisted</h3><p name="8b1d" id="8b1d" class="graf graf--p graf-after--h3">This session reinforced why persistence matters in both technical and personal contexts.</p><p name="0943" id="0943" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Technical persistence</strong>: Database state that survives restarts, workflow history that enables learning, error recovery that maintains system integrity. Without proper persistence, AI systems can’t build on previous interactions or learn from corrections.</p><p name="5052" id="5052" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Development persistence</strong>: Staying with architectural problems until they’re properly solved, rather than patching symptoms. The temptation was to work around the Task class inconsistencies with type casting and special cases. Instead, we invested in fixing the root cause.</p><p name="3b2b" id="3b2b" class="graf graf--p graf-after--p">Product work often offers the temptation to ship quick fixes vs. investing in foundational improvements but that way leads to darkness.</p><h3 name="d4fc" id="d4fc" class="graf graf--h3 graf-after--p">Demo-safe development</h3><p name="a572" id="a572" class="graf graf--p graf-after--h3">With PM-008 functional, we established what I’m calling “demo-safe development” — stable branches that always work for stakeholder presentations, while enabling continued development on feature branches. The <code class="markup--code markup--p-code">demo-stable-pm-008</code> branch represents a known-good state that teams can rely on. If I break things while building out PM-009, I can still revert to the demo branch and show what was working last time things were working.</p><p name="f4aa" id="f4aa" class="graf graf--p graf-after--p">This recognizes that AI systems development is inherently experimental. Features may work intermittently, new capabilities might break existing ones, and architectural changes can have unexpected ripple effects. Having a stable baseline enables confident iteration.</p><h3 name="f40e" id="f40e" class="graf graf--h3 graf-after--p">What I’m learning about building AI tools for PMs</h3><p name="e5fe" id="e5fe" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">Domain-first design pays off</strong>: When building tools for specific disciplines, start with domain concepts rather than technical abstractions. The domain provides natural boundaries that prevent architectural drift.</p><p name="4c53" id="4c53" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Early architecture investment accelerates development</strong>: Time spent on proper design patterns — repository layers, domain models, event sourcing — speeds up development rather than slowing it down. When problems arise, you fix root causes rather than patching symptoms.</p><p name="d821" id="d821" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Environment consistency enables flow</strong>: AI development requires rapid iteration cycles. Anything that breaks the develop-test-iterate loop multiplies development time exponentially.</p><p name="c45b" id="c45b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Real integration validates design</strong>: Mock implementations can hide architectural problems that only surface when connecting to real external systems.</p><h3 name="65b6" id="65b6" class="graf graf--h3 graf-after--p">What came next</h3><p name="6865" id="6865" class="graf graf--p graf-after--h3">PM-008 proved the architectural foundation can support sophisticated AI workflows. With GitHub issue analysis working end-to-end, we were ready to expand to additional PM tasks: automated reporting, multi-repository support, and eventually proactive insights that leverage the learning mechanisms we’ve built.</p><p name="24e5" id="24e5" class="graf graf--p graf-after--p graf--trailing">But first: demos. Having a working system changes everything about stakeholder conversations.</p></div></div></section><section name="7319" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="b94e" id="b94e" class="graf graf--p graf--leading"><em class="markup--em markup--p-em">Next on Building Piper Morgan: “The Cascade Effect” — How testing a simple web interface led to building an entire file resolution system with multi-factor scoring and sub-3ms performance.</em></p><p name="c853" id="c853" class="graf graf--p graf-after--p graf--trailing"><em class="markup--em markup--p-em">Ever had a “simple integration” turn into an architecture archaeology expedition? I’m curious how others handle the balance between shipping quick fixes and investing in foundational improvements.</em></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@mediajunkie" class="p-author h-card">christian crumlish</a> on <a href="https://medium.com/p/201f17c5cfbf"><time class="dt-published" datetime="2025-07-18T13:59:40.710Z">July 18, 2025</time></a>.</p><p><a href="https://medium.com/@mediajunkie/from-architecture-drift-to-working-ai-201f17c5cfbf" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 9, 2025.</p></footer></article></body></html>