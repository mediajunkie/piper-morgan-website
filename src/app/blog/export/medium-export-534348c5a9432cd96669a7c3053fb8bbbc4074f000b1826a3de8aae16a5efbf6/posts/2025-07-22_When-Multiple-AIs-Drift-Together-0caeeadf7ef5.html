<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>When Multiple AIs Drift Together</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">When Multiple AIs Drift Together</h1>
</header>
<section data-field="subtitle" class="p-summary">
June 15, 2025
</section>
<section data-field="body" class="e-content">
<section name="fed2" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="50db" id="50db" class="graf graf--h3 graf--leading graf--title">When Multiple AIs DriftÂ Together</h3><p name="91c8" id="91c8" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">June 15, 2025</em></p><figure name="96a0" id="96a0" class="graf graf--figure graf--startsWithDoubleQuote graf-after--p"><img class="graf-image" data-image-id="1*pdMSlk5-BEHCEm45Nd83LQ.png" data-width="1536" data-height="1024" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*pdMSlk5-BEHCEm45Nd83LQ.png"><figcaption class="imageCaption">â€œWheeeeeee!â€</figcaption></figure><p name="85b4" id="85b4" class="graf graf--p graf--hasDropCapModel graf--hasDropCap graf-after--figure"><span class="graf-dropCap">T</span>here I was, feeling pretty confident about our multi-AI development process. Claude Opus handling architecture reviews, Claude Sonnet doing detailed implementation planning, Cursor providing code execution support. Three different AI perspectives, multiple layers of review, comprehensive test-driven development approach.</p><p name="f20d" id="f20d" class="graf graf--p graf-after--p">And we still managed to create duplicate domain models without anyone catching it.</p><p name="bd74" id="bd74" class="graf graf--p graf-after--p">This is the story of how even systematic AI collaboration can drift into architectural anti-patterns, and why human oversight remains the critical factor in maintaining architectural discipline.</p><h3 name="c1ba" id="c1ba" class="graf graf--h3 graf-after--p">The setup: confidence in systematic process</h3><p name="0312" id="0312" class="graf graf--p graf-after--h3">Weâ€™d been developing Piper Morgan with what felt like a bulletproof process. Every major feature went through multiple review stages:</p><ol class="postList"><li name="44e7" id="44e7" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Architecture review</strong> (Claude Opus)â€Šâ€”â€ŠHigh-level design and pattern consistency</li><li name="5e54" id="5e54" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Implementation planning</strong> (Claude Sonnet)â€Šâ€”â€ŠDetailed step-by-step approach</li><li name="94fa" id="94fa" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Code execution</strong> (Cursor)â€Šâ€”â€ŠSyntax assistance and local development support</li><li name="cf3b" id="cf3b" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Test-first discipline</strong>â€Šâ€”â€ŠComprehensive test suite before any implementation</li></ol><p name="0c84" id="0c84" class="graf graf--p graf-after--li">For tickets PM-001 through PM-008, this process had worked beautifully. Clean implementations, passing tests, architectural consistency maintained.</p><p name="bc67" id="bc67" class="graf graf--p graf-after--p">Those first few issues flew by so fast I barely remember executing them.</p><p name="f380" id="f380" class="graf graf--p graf-after--p">Then came PM-009: multi-project support. And everything that could go wrong with our processâ€¦ did.</p><h3 name="bdfd" id="bdfd" class="graf graf--h3 graf-after--p">The architectural drift discovery</h3><p name="27ff" id="27ff" class="graf graf--p graf-after--h3">The first sign of trouble came during implementation. Cursor was trying to import the <code class="markup--code markup--p-code">Project</code> class and kept getting confused about which one to use:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="c66f" id="c66f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment"># This should have been obvious, but wasn&#x27;t:</span><br /><span class="hljs-keyword">from</span> services.domain.models <span class="hljs-keyword">import</span> Project       <span class="hljs-comment"># Business logic model</span><br /><span class="hljs-keyword">from</span> services.database.models <span class="hljs-keyword">import</span> Project     <span class="hljs-comment"># SQLAlchemy model</span></span></pre><p name="f2da" id="f2da" class="graf graf--p graf-after--pre">Two <code class="markup--code markup--p-code">Project</code> classes. Same name, different purposes, different locations. Both created by our systematic multi-AI process. Both reviewed and approved.</p><p name="9b7e" id="9b7e" class="graf graf--p graf-after--p">None of usâ€Šâ€”â€Šhuman or AIâ€Šâ€”â€Šhad caught the fundamental naming collision.</p><h3 name="3c21" id="3c21" class="graf graf--h3 graf-after--p">The example codeÂ trap</h3><p name="df18" id="df18" class="graf graf--p graf-after--h3">How did three AI systems and a human miss something so fundamental? The answer was hiding in the architectural examples weâ€™d been following.</p><p name="b726" id="b726" class="graf graf--p graf-after--p">The example code showed the <em class="markup--em markup--p-em">structure</em> of domain and database separation:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="31bf" id="31bf" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment"># Domain layer - pure business logic</span><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">Project</span>:<br />    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>: <span class="hljs-built_in">str</span>, name: <span class="hljs-built_in">str</span></span>):<br />        <span class="hljs-comment"># Domain logic here</span><br /><br /><span class="hljs-comment"># Database layer - persistence</span><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">Project</span>(<span class="hljs-title class_ inherited__">Base</span>):  <span class="hljs-comment"># SQLAlchemy model</span><br />    <span class="hljs-built_in">id</span> = Column(String, primary_key=<span class="hljs-literal">True</span>)<br />    <span class="hljs-comment"># Database fields here</span></span></pre><p name="5548" id="5548" class="graf graf--p graf-after--pre">The structure was correct. The separation was proper. But the example didnâ€™t specify the <em class="markup--em markup--p-em">naming convention</em> for avoiding collisions.</p><p name="27e1" id="27e1" class="graf graf--p graf-after--p">We all saw â€œdomain model + database modelâ€ and correctly implemented the separation. None of us saw â€œsame name in different modules = import collisionâ€ until we tried to use both classes in the same scope.</p><h3 name="3dd0" id="3dd0" class="graf graf--h3 graf-after--p">The multi-AI blindÂ spot</h3><p name="9e80" id="9e80" class="graf graf--p graf-after--h3">Whatâ€™s fascinating about this failure is how each AI system made the same logical assumption:</p><p name="3570" id="3570" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Claude Opus</strong> (Architecture): â€œDomain and database layers should be separateâ€ âœ…<br>Â <strong class="markup--strong markup--p-strong">Claude Sonnet</strong> (Implementation): â€œCreate Project models in both layersâ€ âœ…<br>Â <strong class="markup--strong markup--p-strong">Cursor</strong> (Execution): â€œImport Project class as neededâ€ âŒ <em class="markup--em markup--p-em">Which one?</em></p><p name="8488" id="8488" class="graf graf--p graf-after--p">Each step was individually correct. The compound result was architectural confusion.</p><p name="a274" id="a274" class="graf graf--p graf-after--p">By the way, every time I say â€œwe missedâ€ or â€œwe realizedâ€ here, I should clarify that this was happening across multiple AI collaboration sessions. But the moment of recognizing the naming collisionâ€Šâ€”â€Šand realizing it represented a fundamental process gapâ€Šâ€”â€Šthat came from stepping back and asking â€œwhy is this so confusing?â€</p><p name="7785" id="7785" class="graf graf--p graf-after--p">The key thing is a third (really fourth) point of view entered the project and immediately found a flaw none of the rest of us had seen yet.</p><h3 name="5d45" id="5d45" class="graf graf--h3 graf-after--p">The systematic reviewÂ illusion</h3><p name="63a4" id="63a4" class="graf graf--p graf-after--h3">Hereâ€™s what was most humbling about the experience: weâ€™d had <em class="markup--em markup--p-em">comprehensive</em> reviews. Opus had specifically called out concerns about â€œtype safety regressionâ€ and â€œresponsibility diffusion.â€ Sonnet had created detailed implementation plans with step-by-step verification.</p><p name="cbb0" id="cbb0" class="graf graf--p graf-after--p">But none of our systematic reviews had caught the basic naming collision.</p><p name="104c" id="104c" class="graf graf--p graf-after--p">Our review caught complex architectural interactions, business logic edge cases, integration patterns, but they missed things like simple naming conventions and import practicalities</p><p name="3ebb" id="3ebb" class="graf graf--p graf-after--p">This is like having a thorough structural engineering review that catches load-bearing calculations but misses that two different beams have the same catalog number.</p><h3 name="2b1b" id="2b1b" class="graf graf--h3 graf-after--p">The test-driven development assumption</h3><p name="3f1c" id="3f1c" class="graf graf--p graf-after--h3">Weâ€™d been following test-driven development religiously: write comprehensive tests first, then implement to satisfy the tests. The tests were thorough, covering business logic, error cases, integration scenarios.</p><p name="a517" id="a517" class="graf graf--p graf-after--p">But the tests assumed the implementation would follow naming conventions that weâ€™d never explicitly established.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="459f" id="459f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment"># Test assumed this would work:</span><br /><span class="hljs-keyword">from</span> services.domain.models <span class="hljs-keyword">import</span> Project<br /><span class="hljs-keyword">from</span> services.database.models <span class="hljs-keyword">import</span> ProjectDB  <span class="hljs-comment"># We never created ProjectDB!</span></span></pre><p name="11fa" id="11fa" class="graf graf--p graf-after--pre">The tests were architecturally correct. Our implementation didnâ€™t match the architectural assumptions the tests were making. We were using TDD (test-driven development) and forgetting to keep employing DDD (domain-driven design) as we did o, which to the basic PM in me means â€œcheck the stuff we already did and use that before making up new stuff.â€</p><p name="1ff5" id="1ff5" class="graf graf--p graf-after--p">This taught me that test-driven development requires explicit architectural conventions, not just business logic specifications.</p><h3 name="fc01" id="fc01" class="graf graf--h3 graf-after--p">The â€œSTOPâ€Šâ€”â€ŠArchitectural Decision Required!â€ moment</h3><p name="ec88" id="ec88" class="graf graf--p graf-after--h3">The turning point came when Cursor started suggesting breaking our domain-first architecture principles to work around the import collision. When I brought back the proposal with my concerns it set off Claudeâ€™s architectural alarm:</p><p name="4de6" id="4de6" class="graf graf--p graf--startsWithDoubleQuote graf-after--p"><strong class="markup--strong markup--p-strong">â€œSTOPâ€Šâ€”â€ŠArchitectural Decision Required!<br></strong> ğŸš¨ Your Copilot is suggesting breaking our core <strong class="markup--strong markup--p-strong">domain-first architecture</strong> principle.â€</p><p name="c089" id="c089" class="graf graf--p graf-after--p">The collision wasnâ€™t a problem to solve with clever importsâ€Šâ€”â€Šit was a signal that our architectural implementation had drifted from our architectural intentions.</p><h3 name="275a" id="275a" class="graf graf--h3 graf-after--p">The TDD discipline check</h3><p name="a780" id="a780" class="graf graf--p graf-after--h3">Another humbling discovery was realizing weâ€™d even violated our own TDD discipline without noticing. Weâ€™d written comprehensive tests, then implemented based on our understanding rather than implementing to satisfy the tests.</p><p name="6e81" id="6e81" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">TDD principle</strong>: Let tests drive implementation decisions<br><strong class="markup--strong markup--p-strong">What we did</strong>: Implement based on architectural assumptions, then debug why tests failed</p><p name="bd5b" id="bd5b" class="graf graf--p graf-after--p">Six test failures, all from method signature mismatches. The tests expected <code class="markup--code markup--p-code">llm.complete()</code> calls; our implementation used <code class="markup--code markup--p-code">llm.infer_project_id()</code>. The tests were right. Our implementation was guessing.</p><p name="645f" id="645f" class="graf graf--p graf-after--p">Complex features donâ€™t excuse abandoning good processâ€Šâ€”â€Šthey require <em class="markup--em markup--p-em">more</em> discipline, not less.</p><h3 name="6c1d" id="6c1d" class="graf graf--h3 graf-after--p">The architectural anti-pattern recognition</h3><p name="8f5b" id="8f5b" class="graf graf--p graf-after--h3">Once we recognized the naming collision, we could see the broader anti-pattern:</p><p name="84fd" id="84fd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Anti-pattern</strong>: Same entity name in multiple layers<br><strong class="markup--strong markup--p-strong">Correct pattern</strong>: Layer-specific naming with explicit mapping</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="b7f5" id="b7f5" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment"># Anti-pattern (what we built):</span><br />services.domain.models.Project<br />services.database.models.Project<br /><br /><span class="hljs-comment"># Correct pattern (what we should have built):</span><br />services.domain.models.Project       <span class="hljs-comment"># Business logic</span><br />services.database.models.ProjectDB   <span class="hljs-comment"># Persistence + mapping methods</span></span></pre><p name="813e" id="813e" class="graf graf--p graf-after--pre">The fix required systematic refactoring, but once we made the change, everything else became obvious.</p><h3 name="4662" id="4662" class="graf graf--h3 graf-after--p">The human oversight revelation</h3><p name="65b8" id="65b8" class="graf graf--p graf-after--h3">The most important insight from this experience was about the irreplaceable role of human oversight in AI collaboration.</p><p name="8884" id="8884" class="graf graf--p graf-after--p">AIs are excellent at following patterns, implementing specifications, and maintaining consistency within established frameworks. But they can collectively drift when the framework itself has gaps.</p><p name="3e1f" id="3e1f" class="graf graf--p graf-after--p">AIs caught complex logic errors, business rule violations, integration issues, but my human oversight became essential for recognizing when systematic process had systematic blind spots</p><p name="0a6f" id="0a6f" class="graf graf--p graf-after--p">The human role isnâ€™t just coordinating AI systemsâ€Šâ€”â€Šitâ€™s maintaining architectural vigilance that spans multiple AI perspectives.</p><h3 name="b4a2" id="b4a2" class="graf graf--h3 graf-after--p">The discipline to stop and fix rootÂ causes</h3><p name="35c5" id="35c5" class="graf graf--p graf-after--h3">When we discovered the architectural anti-pattern, we had a choice:</p><ol class="postList"><li name="bc75" id="bc75" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Patch it</strong>: Use import aliases and namespaces to work around the collision</li><li name="de95" id="de95" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Fix it</strong>: Rename one class and establish proper naming conventions</li></ol><p name="f5bb" id="f5bb" class="graf graf--p graf-after--li">Patching always feels faster. Fixing can feel like â€œgoing backwardsâ€ but architectural problems that get patched instead of fixed tend to compound. We chose systematic repair over tactical workarounds.</p><h3 name="0203" id="0203" class="graf graf--h3 graf-after--p">Collaboration patternÂ insights</h3><p name="5faa" id="5faa" class="graf graf--p graf-after--h3">The experience taught me several things about effective AI collaboration:</p><p name="6d73" id="6d73" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Multiple perspectives help but donâ€™t guarantee correctness</strong>: Each AI system brought valuable insights, but they could all miss the same fundamental issue.</p><p name="d352" id="d352" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Reviews need explicit checklists</strong>: â€œDoes this follow our patterns?â€ isnâ€™t enough. â€œAre there naming collisions?â€ needs to be a specific check.</p><p name="17f9" id="17f9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Implementation-time validation matters</strong>: Even with thorough planning, drift happens during execution. Regular â€œdoes this match our intentions?â€ checks are essential.</p><p name="b54a" id="b54a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Human pattern recognition is different</strong>: AIs excel at consistency within established patterns. Humans are better at recognizing when patterns themselves need revision.</p><h3 name="439a" id="439a" class="graf graf--h3 graf-after--p">A test-first architecture lesson</h3><p name="d194" id="d194" class="graf graf--p graf-after--h3">One outcome of the debugging session was establishing â€œtest-first architectureâ€ as a discipline:</p><p name="0ecd" id="0ecd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Test-first development</strong>: Write tests before implementation<br><strong class="markup--strong markup--p-strong">Test-first architecture</strong>: Make architectural assumptions explicit in test structure</p><p name="04af" id="04af" class="graf graf--p graf-after--p">Our tests assumed <code class="markup--code markup--p-code">ProjectDB</code> naming but we&#39;d never explicitly documented that convention. The tests were more architecturally correct than our implementation.</p><p name="be88" id="be88" class="graf graf--p graf-after--p">Sometimes your tests know more about good architecture than your implementation does.</p><h3 name="894e" id="894e" class="graf graf--h3 graf-after--p">The systematic recoveryÂ template</h3><p name="6210" id="6210" class="graf graf--p graf-after--h3">The process we used to recover from the architectural drift became a template for future issues:</p><ol class="postList"><li name="710a" id="710a" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Stop adding complexity</strong>â€Šâ€”â€ŠNo more patches or workarounds</li><li name="fe28" id="fe28" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Identify the root pattern violation</strong>â€Šâ€”â€ŠNaming collision, not import issue</li><li name="9c2c" id="9c2c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Fix systematically</strong>â€Šâ€”â€ŠRename + establish conventions, donâ€™t just patch</li><li name="c5c6" id="c5c6" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Verify architectural alignment</strong>â€Šâ€”â€ŠMake sure fix matches intended patterns</li><li name="85a4" id="85a4" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Document the lesson</strong>â€Šâ€”â€ŠUpdate process to prevent recurrence</li></ol><p name="fa92" id="fa92" class="graf graf--p graf-after--li">This systematic approach to architectural problems became part of our standard toolkit.</p><h3 name="817b" id="817b" class="graf graf--h3 graf-after--p">The confidence recalibration</h3><p name="d478" id="d478" class="graf graf--p graf-after--h3">Perhaps the most valuable outcome was recalibrating confidence in our systematic process. Multiple AI perspectives are incredibly valuable, but theyâ€™re not infallible.</p><p name="d360" id="d360" class="graf graf--p graf-after--p">Less â€œWe have systematic reviews, so architectural drift wonâ€™t happenâ€ and more â€œWe have systematic reviews, so architectural drift will be caught quickly.â€</p><p name="89ed" id="89ed" class="graf graf--p graf-after--p">The difference is subtle but important. Good process doesnâ€™t prevent all problemsâ€Šâ€”â€Šit makes problems visible and recoverable.</p><h3 name="6053" id="6053" class="graf graf--h3 graf-after--p">The importance of architectural examples</h3><p name="6187" id="6187" class="graf graf--p graf-after--h3">This experience also taught me about the responsibility of creating architectural examples. Examples that show structure without naming conventions can mislead even systematic implementors.</p><p name="fc0b" id="fc0b" class="graf graf--p graf-after--p">Good examples need:</p><p name="04fd" id="04fd" class="graf graf--p graf-after--p">structure + naming + boundaries + common pitfalls</p><p name="98be" id="98be" class="graf graf--p graf-after--p">(Incomplete examples create correct understanding of relationships but incorrect implementation details.)</p><p name="4ff9" id="4ff9" class="graf graf--p graf-after--p">Example creators bear responsibility for the blind spots their examples might create.</p><h3 name="90f7" id="90f7" class="graf graf--h3 graf-after--p">Insight about compound AIÂ wisdom</h3><p name="1fe5" id="1fe5" class="graf graf--p graf-after--h3">What I learned about AI collaboration is that compound AI wisdom isnâ€™t just additiveâ€Šâ€”â€Šitâ€™s multiplicative when working well, but it can also multiply blind spots when all systems make the same assumption.</p><p name="3d86" id="3d86" class="graf graf--p graf-after--p">Different perspectives catch different issues <em class="markup--em markup--p-em">and s</em>hared assumptions can hide fundamental problems</p><p name="eb02" id="eb02" class="graf graf--p graf-after--p">The solution isnâ€™t â€œfewer AI perspectivesâ€â€Šâ€”â€Šitâ€™s better coordination and explicit human oversight of the coordination process.</p><h3 name="57b0" id="57b0" class="graf graf--h3 graf-after--p">Practicing architectural vigilance</h3><p name="1e02" id="1e02" class="graf graf--p graf-after--h3">The most practical outcome was establishing â€œarchitectural vigilanceâ€ as an explicit practice:</p><p name="e922" id="e922" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Regular questions</strong>: Are we following our own patterns? Do our implementations match our intentions? Are we creating accidental complexity?</p><p name="62ac" id="62ac" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Explicit checks</strong>: Naming consistency, import cleanliness, layer separation, pattern adherence</p><p name="cd22" id="cd22" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Human responsibility</strong>: Maintaining architectural perspective that spans multiple AI contributions. What I like to callÂ :the primate in the loop.â€</p><p name="40cf" id="40cf" class="graf graf--p graf-after--p">Vigilance isnâ€™t (just) about not trusting AI systemsâ€Šâ€”â€Šitâ€™s about taking responsibility for the overall architectural coherence they help create.</p><h3 name="397f" id="397f" class="graf graf--h3 graf-after--p">The foreshadowingâ€¦</h3><p name="4406" id="4406" class="graf graf--p graf-after--h3">Looking back, this architectural drift experience set up everything that followed. The systematic recovery approach we developed here became the foundation for handling the complexity accumulation that built up through PM-009.</p><p name="c560" id="c560" class="graf graf--p graf-after--p graf--trailing">Learning to catch and fix architectural drift quickly made it possible to manage the technical debt that accumulated during more complex implementations.</p></div></div></section><section name="34de" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="2115" id="2115" class="graf graf--p graf--leading"><em class="markup--em markup--p-em">Next on Building Piper Morgan: more tales of white-knuckle architectural rigor when we are getting tired and just wanna go home!</em></p><p name="e697" id="e697" class="graf graf--p graf-after--p graf--trailing"><em class="markup--em markup--p-em">Whatâ€™s your experience with AI collaboration and architectural oversight? Have you seen systematic processes miss fundamental issues? Iâ€™d love to hear about your own experiences with multiple AI perspectives and the human oversight that makes them effective.</em></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@mediajunkie" class="p-author h-card">christian crumlish</a> on <a href="https://medium.com/p/0caeeadf7ef5"><time class="dt-published" datetime="2025-07-22T15:49:34.027Z">July 22, 2025</time></a>.</p><p><a href="https://medium.com/@mediajunkie/when-multiple-ais-can-still-drift-together-0caeeadf7ef5" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 9, 2025.</p></footer></article></body></html>