<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Following Your Own Patterns</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Following Your Own Patterns</h1>
</header>
<section data-field="subtitle" class="p-summary">
June 28, 2025
</section>
<section data-field="body" class="e-content">
<section name="8405" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="b443" id="b443" class="graf graf--h3 graf--leading graf--title">Following Your Own Patterns</h3><figure name="e63b" id="e63b" class="graf graf--figure graf--startsWithDoubleQuote graf-after--h3"><img class="graf-image" data-image-id="1*eNoAB_jw8BGGMhWMYNgdQw.png" data-width="1536" data-height="1024" data-is-featured="true" alt="A person and a robot steer a ship by the stars" src="https://cdn-images-1.medium.com/max/800/1*eNoAB_jw8BGGMhWMYNgdQw.png"><figcaption class="imageCaption">“Straight on till morning!”</figcaption></figure><p name="9995" id="9995" class="graf graf--p graf-after--figure"><em class="markup--em markup--p-em">June 28, 2025</em></p><p name="9a61" id="9a61" class="graf graf--p graf--hasDropCapModel graf--hasDropCap graf-after--p"><span class="graf-dropCap">H</span>ere’s what happened when we went to add GitHub integration to Piper Morgan: it took about an hour, and most of that was just writing the tests.</p><p name="ca0c" id="ca0c" class="graf graf--p graf-after--p">Not because GitHub integration is simple (though their API is quite nice). Not because we cut corners or built something half-baked. But because we’d finally reached that magical state where your architecture makes new features feel inevitable rather than difficult.</p><p name="846f" id="846f" class="graf graf--p graf-after--p">This is the story of what it looks like when you start following your own patterns instead of fighting them.</p><h3 name="f92e" id="f92e" class="graf graf--h3 graf-after--p">Building on clean foundations</h3><p name="98d7" id="98d7" class="graf graf--p graf-after--h3">Coming off our technical debt cleanup from a couple days earlier — where we’d consolidated two orchestration systems into one and actually wrote tests for the system we were using — I was ready to tackle GitHub integration.</p><p name="7139" id="7139" class="graf graf--p graf-after--p">The plan was straightforward: enable users to say “create a ticket for this bug” and have Piper automatically create a properly formatted GitHub issue in the right repository with all the relevant context.</p><p name="523b" id="523b" class="graf graf--p graf-after--p">This was something the prototype was doing on, like, it’s second day, so I was pretty excited to be getting this MVP feature working in “the real thing.”</p><p name="a331" id="a331" class="graf graf--p graf-after--p">What I didn’t expect was how <em class="markup--em markup--p-em">obvious</em> the implementation path would be once we started following the patterns we’d already established.</p><h3 name="8757" id="8757" class="graf graf--h3 graf-after--p">Architecture that teaches you how to use it</h3><p name="e991" id="e991" class="graf graf--p graf-after--h3">Good architecture is like a well-designed kitchen: once you understand the layout, everything has a logical place and the workflow feels natural.</p><p name="6c4e" id="6c4e" class="graf graf--p graf-after--p">When we started looking at GitHub integration, the OrchestrationEngine pattern we’d been developing basically told us exactly what to do:</p><ol class="postList"><li name="768f" id="768f" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Task handlers</strong> manage specific types of work</li><li name="a5e3" id="a5e3" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Context enrichment</strong> happens during workflow creation</li><li name="ebd9" id="ebd9" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Repository pattern</strong> keeps external integrations separate from business logic</li><li name="1ae9" id="1ae9" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Error handling</strong> follows established domain contracts</li></ol><p name="fd05" id="fd05" class="graf graf--p graf-after--li">We didn’t have to invent new patterns. We just had to follow the ones we’d already discovered worked.</p><p name="5358" id="5358" class="graf graf--p graf-after--p">The pattern recognition — seeing how GitHub integration could fit into our existing approach —came from having clean, consistent architecture to work from.</p><h3 name="2118" id="2118" class="graf graf--h3 graf-after--p">The internal task handler revelation</h3><p name="e1ef" id="e1ef" class="graf graf--p graf-after--h3">The first decision point was where to put the GitHub integration logic. In our earlier technical debt cleanup, we’d established that OrchestrationEngine was our canonical orchestration system. But how should new task types connect to it? We had three choices:</p><ol class="postList"><li name="dc3e" id="dc3e" class="graf graf--li graf-after--p">Create separate GitHubTaskHandler classes</li><li name="3fc2" id="3fc2" class="graf graf--li graf-after--li">Build handlers as internal methods within OrchestrationEngine</li><li name="b033" id="b033" class="graf graf--li graf-after--li">Create some hybrid plugin architecture</li></ol><p name="77f4" id="77f4" class="graf graf--p graf-after--li">When we looked at how file analysis was already integrated, the answer was obvious: OrchestrationEngine used internal methods, not separate handler classes.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="php" name="9af8" id="9af8" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment"># The pattern we&#x27;d already established:</span><br /><span class="hljs-built_in">self</span>.task_handlers = {<br />    TaskType.ANALYZE_FILE: <span class="hljs-built_in">self</span>._analyze_file,<br />    TaskType.PROCESS_CONTENT: <span class="hljs-built_in">self</span>._process_content<br />}<br /><br /><span class="hljs-comment"># So GitHub integration became:</span><br /><span class="hljs-built_in">self</span>.task_handlers[TaskType.GITHUB_CREATE_ISSUE] = <span class="hljs-built_in">self</span>._create_github_issue</span></pre><p name="4cb9" id="4cb9" class="graf graf--p graf-after--pre">This wasn’t a grand architectural decision — it was just following the pattern that was already working.</p><h3 name="f5a0" id="f5a0" class="graf graf--h3 graf-after--p">The context enrichment pattern</h3><p name="064f" id="064f" class="graf graf--p graf-after--h3">The second insight came when we thought about user experience. Nobody wants to specify which repository to create an issue in every time they ask for a ticket. The system should just know.</p><p name="f27d" id="f27d" class="graf graf--p graf-after--p">But how do you “just know” which repository to use without requiring users to specify it every time?</p><p name="25eb" id="25eb" class="graf graf--p graf-after--p">The answer was hiding in plain sight: we already had a context enrichment pattern from file analysis. When a workflow gets created, we automatically look up and add relevant context that the task handlers will need.</p><p name="ffda" id="ffda" class="graf graf--p graf-after--p">For GitHub integration, that meant:</p><ul class="postList"><li name="68e5" id="68e5" class="graf graf--li graf-after--p">Look up the project’s GitHub integration configuration</li><li name="3396" id="3396" class="graf graf--li graf-after--li">Find the repository associated with the project</li><li name="62e3" id="62e3" class="graf graf--li graf-after--li">Add that repository context to the workflow automatically</li><li name="84f9" id="84f9" class="graf graf--li graf-after--li">Let the task handler just use the context that’s already there</li></ul><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="e4af" id="e4af" class="graf graf--pre graf-after--li graf--preV2"><span class="pre--content"><span class="hljs-comment"># Context enrichment during workflow creation</span><br /><span class="hljs-keyword">if</span> workflow.<span class="hljs-built_in">type</span> == WorkflowType.CREATE_TICKET:<br />    github_config = <span class="hljs-keyword">await</span> self._get_github_config(project_id)<br />    <span class="hljs-keyword">if</span> github_config:<br />        workflow.context[<span class="hljs-string">&quot;repository&quot;</span>] = github_config.repository</span></pre><p name="f3bf" id="f3bf" class="graf graf--p graf-after--pre">Seamless user experience through systematic context management.</p><h3 name="92b9" id="92b9" class="graf graf--h3 graf-after--p">When patterns accelerate development</h3><p name="99fb" id="99fb" class="graf graf--p graf-after--h3">Here’s what was remarkable about following our established patterns: the implementation work became almost mechanical.</p><p name="6b8f" id="6b8f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Task registration</strong>: Add the task type to the enum, map it to the handler method</p><p name="b58a" id="b58a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Handler implementation</strong>: Follow the established signature (workflow, task) → TaskResult</p><p name="e463" id="e463" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Error handling</strong>: Return results with error metadata, never throw exceptions</p><p name="86d1" id="86d1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Testing</strong>: Write tests that verify the handler behavior, not the internal implementation</p><p name="a54d" id="a54d" class="graf graf--p graf-after--p">We didn’t have to make architectural decisions because the architecture had already been decided. We didn’t have to debate error handling approaches because we’d already established the domain contract. We didn’t have to figure out how to structure tests because we had working examples.</p><p name="fef4" id="fef4" class="graf graf--p graf-after--p">The result: GitHub integration that felt like a natural extension of the system rather than something bolted on.</p><h3 name="15c1" id="15c1" class="graf graf--h3 graf-after--p">The repository context enrichment insight</h3><p name="04f8" id="04f8" class="graf graf--p graf-after--h3">The most elegant part of the implementation was the repository context enrichment. Users can just say “create a ticket” without specifying where, and the system figures it out automatically.</p><p name="e777" id="e777" class="graf graf--p graf-after--p">But here’s the architectural insight: this works because we designed it as a <em class="markup--em markup--p-em">non-blocking</em> enrichment. If the system can’t find GitHub configuration for a project, it doesn’t fail the workflow creation — it just logs a warning and lets the task handler deal with the missing context gracefully.</p><p name="1c11" id="1c11" class="graf graf--p graf-after--p">This pattern enables a much better user experience:</p><ul class="postList"><li name="8107" id="8107" class="graf graf--li graf-after--p">Power users get automatic repository detection</li><li name="0c12" id="0c12" class="graf graf--li graf-after--li">New users get helpful error messages about missing configuration</li><li name="a392" id="a392" class="graf graf--li graf-after--li">The system remains functional even when integrations aren’t perfectly set up</li></ul><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="e07b" id="e07b" class="graf graf--pre graf-after--li graf--preV2"><span class="pre--content"><span class="hljs-comment"># Non-blocking enrichment pattern</span><br /><span class="hljs-keyword">try</span>:<br />    repository = <span class="hljs-keyword">await</span> self._lookup_repository(project_id)<br />    workflow.context[<span class="hljs-string">&quot;repository&quot;</span>] = repository<br /><span class="hljs-keyword">except</span> ConfigurationError:<br />    logger.warning(<span class="hljs-string">f&quot;No GitHub repository configured for project <span class="hljs-subst">{project_id}</span>&quot;</span>)<br />    <span class="hljs-comment"># Workflow continues without repository context</span></span></pre><p name="6209" id="6209" class="graf graf--p graf-after--pre">Graceful degradation built into the architecture from the start.</p><h3 name="118e" id="118e" class="graf graf--h3 graf-after--p">Getting disciplined about documentation</h3><p name="600d" id="600d" class="graf graf--p graf-after--h3">Once the implementation was working, we had a choice: ship it and move on, or take the time to document what we’d learned.</p><p name="d04f" id="d04f" class="graf graf--p graf-after--p">This is where following your own patterns really pays off. We’d established during our technical debt cleanup that architectural discoveries should be documented immediately, not “when we have time later.”</p><p name="6ced" id="6ced" class="graf graf--p graf-after--p">So we updated six different documentation files:</p><ul class="postList"><li name="b176" id="b176" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">architecture.md</strong>: GitHub integration status and new patterns</li><li name="c3a6" id="c3a6" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">pattern-catalog.md</strong>: Internal Task Handler Pattern and Repository Context Enrichment Pattern</li><li name="2b63" id="2b63" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">technical-spec.md</strong>: Orchestration details and GitHub examples</li><li name="08d9" id="08d9" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">data-model.md</strong>: Workflow context structures</li><li name="3f9a" id="3f9a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">api-reference.md</strong>: GitHub-specific usage examples</li><li name="3dac" id="3dac" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">api-specification.md</strong>: Complete API contracts</li></ul><p name="96b6" id="96b6" class="graf graf--p graf-after--li">Six files. In one session. Because we’d learned that architectural insights are fragile — if you don’t capture them immediately, you lose the context that made them insights in the first place. Plus, let’s face it, bots write docs fast.</p><h3 name="8150" id="8150" class="graf graf--h3 graf-after--p">Pattern discovery vs. pattern following</h3><p name="1bd4" id="1bd4" class="graf graf--p graf-after--h3">What struck me about this session was the difference between discovering patterns (what we’d been doing in earlier development) and following patterns (what we were doing now).</p><p name="3451" id="3451" class="graf graf--p graf-after--p">Pattern discovery is hard work: lots of false starts, architectural decisions, refactoring when you realize your first approach doesn’t scale. Pattern following is… well, it’s almost easy. Not because the work itself is simple, but because the decisions have already been made. You’re implementing, not architecting.</p><p name="557d" id="557d" class="graf graf--p graf-after--p">This is what good architecture gets you: it makes the next feature obvious.</p><h3 name="10d2" id="10d2" class="graf graf--h3 graf-after--p">The compound effects of consistency</h3><p name="7b94" id="7b94" class="graf graf--p graf-after--h3">By following established patterns instead of inventing new ones, we got several benefits we didn’t expect:</p><p name="6511" id="6511" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Testing became routine</strong>: Same patterns as file analysis testing, just different inputs and outputs</p><p name="f94e" id="f94e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Error handling was automatic</strong>: Domain contract already established, just needed to follow it</p><p name="2576" id="2576" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Integration felt natural</strong>: New functionality flowed through existing orchestration without friction</p><p name="a7c1" id="a7c1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Documentation was straightforward</strong>: Adding to established pattern catalogs rather than documenting entirely new approaches</p><p name="e2b1" id="e2b1" class="graf graf--p graf-after--p">Most importantly: <strong class="markup--strong markup--p-strong">the next developer</strong> (including future us) would immediately understand how GitHub integration worked, because it followed the same patterns as everything else in the system.</p><h3 name="93ab" id="93ab" class="graf graf--h3 graf-after--p">When architecture becomes invisible</h3><p name="f4f7" id="f4f7" class="graf graf--p graf-after--h3">The best architecture is invisible architecture. Not because you can’t see it, but because it feels so natural that you stop thinking about it.</p><p name="f74c" id="f74c" class="graf graf--p graf-after--p">During this GitHub integration session, we spent very little time making architectural decisions. Instead, we spent time implementing features, writing tests, and documenting patterns.</p><p name="6ce7" id="6ce7" class="graf graf--p graf-after--p">The architecture had become the <em class="markup--em markup--p-em">foundation</em> for work rather than the <em class="markup--em markup--p-em">subject</em> of work.</p><p name="64e4" id="64e4" class="graf graf--p graf-after--p">This is what systematic architectural cleanup gets you: the ability to focus on solving user problems instead of solving architectural problems.</p><h3 name="9fca" id="9fca" class="graf graf--h3 graf-after--p">The “Internal Task Handler” pattern</h3><p name="8dd4" id="8dd4" class="graf graf--p graf-after--h3">One of the patterns we documented was the “Internal Task Handler Pattern” — the decision to implement task handlers as methods within OrchestrationEngine rather than separate classes.</p><p name="15e7" id="15e7" class="graf graf--p graf-after--p">This wasn’t a grand architectural vision. It emerged from practical considerations:</p><ul class="postList"><li name="3866" id="3866" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Simpler architecture</strong>: Fewer files, fewer abstractions to maintain</li><li name="a1da" id="a1da" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Direct access</strong>: Task handlers can access engine state and dependencies directly</li><li name="0af9" id="0af9" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Easier testing</strong>: Test the orchestration engine as a unit, not a collection of loosely coupled handlers</li></ul><p name="68a6" id="68a6" class="graf graf--p graf-after--li">But documenting it as a pattern meant future integrations could follow the same approach without having to rediscover the reasoning.</p><p name="8f2e" id="8f2e" class="graf graf--p graf-after--p">Sometimes the best architectural decisions are the ones you don’t have to make because someone (even if it was past you) already made them thoughtfully.</p><h3 name="efc9" id="efc9" class="graf graf--h3 graf-after--p">The “Repository Context Enrichment” pattern</h3><p name="6c48" id="6c48" class="graf graf--p graf-after--h3">The other pattern we documented was “Repository Context Enrichment” — the automatic lookup and injection of GitHub repository information during workflow creation.</p><p name="762a" id="762a" class="graf graf--p graf-after--p">This pattern enables the “just works” user experience: say “create a ticket” and the system figures out where to create it based on your project configuration.</p><p name="e8e0" id="e8e0" class="graf graf--p graf-after--p">But the <em class="markup--em markup--p-em">pattern</em> is more general: <strong class="markup--strong markup--p-strong">context enrichment</strong> can apply to any external integration where users shouldn’t have to specify configuration details every time they want to use a feature.</p><p name="62a5" id="62a5" class="graf graf--p graf-after--p">Future integrations (Slack, Jira, email) can follow the same pattern: look up configuration during workflow creation, inject context automatically, handle missing configuration gracefully.</p><h3 name="6d33" id="6d33" class="graf graf--h3 graf-after--p">What following patterns teaches you</h3><p name="4120" id="4120" class="graf graf--p graf-after--h3">Following your own patterns teaches you things about your system that you didn’t know you knew.</p><p name="b3e6" id="b3e6" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Consistency compounds</strong>: When every integration follows the same approach, the cognitive load for adding new integrations decreases over time</p><p name="54d7" id="54d7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Documentation matters</strong>: Patterns only help if they’re documented well enough for future developers to follow</p><p name="27df" id="27df" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Error handling is architecture</strong>: How you handle missing configuration or failed operations is as important as how you handle success cases</p><p name="c980" id="c980" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">User experience is systematic</strong>: Good UX comes from consistent system behavior, not just individual feature polish</p><p name="4e9e" id="4e9e" class="graf graf--p graf-after--p">Most importantly: <strong class="markup--strong markup--p-strong">good patterns make good features feel inevitable</strong>. Users don’t think “wow, the GitHub integration is so well-architected.” They think “of course creating tickets works exactly like I expected it to.”</p><h3 name="0723" id="0723" class="graf graf--h3 graf-after--p">The velocity paradox: speed soothes</h3><p name="7d64" id="7d64" class="graf graf--p graf-after--h3">Here’s the paradox of following patterns: the session where we added GitHub integration felt almost boring compared to our earlier architectural discovery sessions.</p><p name="a0db" id="a0db" class="graf graf--p graf-after--p">No major insights. No breakthrough moments. No complex problems to solve. Just… implementing a feature according to established patterns and documenting what we learned.</p><p name="7c36" id="7c36" class="graf graf--p graf-after--p">But that “boring” implementation session was actually the payoff for all the earlier architectural work. The ability to add significant functionality without drama is what good architecture provides.</p><p name="8784" id="8784" class="graf graf--p graf-after--p">Sometimes the most productive sessions are the ones where you don’t have to solve any architectural problems because you’ve already solved them.</p><h3 name="0174" id="0174" class="graf graf--h3 graf-after--p">Building pattern literacy</h3><p name="7cf7" id="7cf7" class="graf graf--p graf-after--h3">One thing this session reminded me is that pattern literacy — the ability to recognize and follow established approaches — is a different skill from pattern discovery. And I’m an old pattern guy from way back!</p><p name="00e2" id="00e2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Pattern discovery</strong> requires architectural thinking, systems perspective, willingness to experiment and refactor.</p><p name="76e7" id="76e7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Pattern following</strong> requires discipline, attention to detail, and the humility to implement rather than innovate when innovation isn’t needed.</p><p name="1134" id="1134" class="graf graf--p graf-after--p">Both skills are essential. But knowing when to use which skill might be the most important skill of all.</p><h3 name="c25d" id="c25d" class="graf graf--h3 graf-after--p">The systematic documentation payoff</h3><p name="8268" id="8268" class="graf graf--p graf-after--h3">Updating six documentation files in one session might seem like overhead, but it paid immediate dividends. When we tested the GitHub integration the next day and ran into issues, the documentation we’d written helped us debug problems and understand the intended behavior.</p><p name="601f" id="601f" class="graf graf--p graf-after--p">Good documentation isn’t just helpful for other developers — it’s helpful for <em class="markup--em markup--p-em">you</em>, debugging your own code weeks later when you’ve forgotten the design decisions that seemed obvious at the time.</p><p name="4999" id="4999" class="graf graf--p graf-after--p">Plus, systematic documentation discipline means you never lose architectural insights. The Internal Task Handler Pattern and Repository Context Enrichment Pattern are now part of our permanent architectural toolkit, not just “something we did that one time.”</p><h3 name="a776" id="a776" class="graf graf--h3 graf-after--p">The series arc</h3><p name="f6de" id="f6de" class="graf graf--p graf-after--h3">Looking back at the sequence of sessions — technical debt cleanup, test guidance, and now systematic implementation — I can see how each session built on the previous ones.</p><p name="c62f" id="c62f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Clean architecture</strong> (from debt cleanup) enabled <strong class="markup--strong markup--p-strong">test guidance</strong> (domain contract clarity) which enabled <strong class="markup--strong markup--p-strong">pattern following</strong> (systematic implementation).</p><p name="1863" id="1863" class="graf graf--p graf-after--p">None of these sessions would have worked as well in isolation. But together, they created a compound effect where each improvement made the next improvement easier.</p><h3 name="1dda" id="1dda" class="graf graf--h3 graf-after--p">When good architecture feels effortless</h3><p name="c696" id="c696" class="graf graf--p graf-after--h3">The best measure of good architecture isn’t how impressive it looks in diagrams. It’s how effortless it makes future development feel.</p><p name="ab2c" id="ab2c" class="graf graf--p graf-after--p">After this GitHub integration session, I had confidence that the next integration (whatever it might be) would follow similar patterns and feel similarly straightforward. Not because the individual features would be simple, but because the architectural decisions wouldn’t need to be re-made.</p><p name="5fbe" id="5fbe" class="graf graf--p graf-after--p graf--trailing">This is what “following your own patterns” really means: building on your past good decisions instead of starting over every time.</p></div></div></section><section name="c7a7" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="1965" id="1965" class="graf graf--p graf--leading"><em class="markup--em markup--p-em">Next on Building Piper Morgan: “Battle-Testing Your Architecture” — how real-world testing reveals the difference between working code and resilient systems.</em></p><p name="ad9b" id="ad9b" class="graf graf--p graf-after--p graf--trailing"><em class="markup--em markup--p-em">What’s your experience with architectural patterns? Have you reached that point where new features feel inevitable rather than difficult? I’d love to hear about moments when following established patterns made complex work feel effortless.</em></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@mediajunkie" class="p-author h-card">christian crumlish</a> on <a href="https://medium.com/p/0822585cb51a"><time class="dt-published" datetime="2025-07-29T13:30:53.344Z">July 29, 2025</time></a>.</p><p><a href="https://medium.com/@mediajunkie/following-your-own-patterns-0822585cb51a" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 9, 2025.</p></footer></article></body></html>