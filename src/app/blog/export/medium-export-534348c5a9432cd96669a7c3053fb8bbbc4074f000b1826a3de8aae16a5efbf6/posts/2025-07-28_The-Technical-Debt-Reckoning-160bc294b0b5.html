<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>The Technical Debt Reckoning</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">The Technical Debt Reckoning</h1>
</header>
<section data-field="subtitle" class="p-summary">
June 26
</section>
<section data-field="body" class="e-content">
<section name="9778" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="06be" id="06be" class="graf graf--h3 graf--leading graf--title">The Technical Debt Reckoning</h3><figure name="c6b8" id="c6b8" class="graf graf--figure graf--startsWithDoubleQuote graf-after--h3"><img class="graf-image" data-image-id="1*9K8ihqlVqOsm0n7P7Ej85g.png" data-width="1536" data-height="1024" data-is-featured="true" alt="An inventor can’t understand why his robot has three arms" src="https://cdn-images-1.medium.com/max/800/1*9K8ihqlVqOsm0n7P7Ej85g.png"><figcaption class="imageCaption">“What’s that doing there?”</figcaption></figure><p name="776f" id="776f" class="graf graf--p graf-after--figure"><em class="markup--em markup--p-em">June 26</em></p><p name="792c" id="792c" class="graf graf--p graf--hasDropCapModel graf--hasDropCap graf-after--p"><span class="graf-dropCap">So</span> there I was, supposedly at the end of a successful integration sprint, staring at what should have been a celebration moment, and instead discovering I’d accidentally built two orchestration systems.</p><p name="d3c2" id="d3c2" class="graf graf--p graf-after--p">And only one of them actually worked.</p><p name="8460" id="8460" class="graf graf--p graf-after--p">This is the kind of discovery that makes you question everything you thought you knew about your own codebase. Like finding out you’ve been wearing mismatched socks for a week, except instead of socks, it’s fundamental architecture, and instead of a week, it’s… well, however long it takes to accidentally build duplicate systems without noticing.</p><p name="0529" id="0529" class="graf graf--p graf-after--p">Welcome to the technical debt reckoning.</p><h3 name="97c5" id="97c5" class="graf graf--h3 graf-after--p">Success with a side of confusion</h3><p name="dd79" id="dd79" class="graf graf--p graf-after--h3">We’d just completed a major integration milestone. File analysis was working end-to-end. The tests were passing. Users could upload files, get intelligent analysis, and everything flowed through our task-based architecture beautifully.</p><p name="1e22" id="1e22" class="graf graf--p graf-after--p">But as I started preparing for the next integration (GitHub functionality), I kept running into this nagging confusion about which orchestration system I was supposed to use (without really understanding what was going on).</p><p name="a812" id="a812" class="graf graf--p graf-after--p">There was OrchestrationEngine — the newer, cleaner task-based architecture that aligned perfectly with our domain models. And there was WorkflowExecutor — the older system that had grown organically from our early GitHub proof-of-concept work.</p><p name="d1b3" id="d1b3" class="graf graf--p graf-after--p">Both worked. Both had tests. Both were actively maintained. And I had no clear memory of making a conscious decision to keep both. This is a side effect of working with AIs that “know” a lot more about programming than I do. They suggest things, I say “that sounds good,” and the implications escape me. (I try to ask for tradeoffs and pros and cons these days!)</p><h3 name="2a64" id="2a64" class="graf graf--h3 graf-after--p">The detective work begins</h3><p name="7416" id="7416" class="graf graf--p graf-after--h3">When you suspect architectural confusion, you start with the basics: grep for usage patterns and see what’s actually running in production.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="perl" name="4d48" id="4d48" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">grep</span> -r <span class="hljs-string">&quot;OrchestrationEngine&quot;</span> services/<br /><span class="hljs-keyword">grep</span> -r <span class="hljs-string">&quot;WorkflowExecutor&quot;</span> services/</span></pre><p name="6e05" id="6e05" class="graf graf--p graf-after--pre">What I found was… interesting.</p><p name="58c9" id="58c9" class="graf graf--p graf-after--p">OrchestrationEngine was everywhere the application was actually working. The main API used it exclusively. File analysis flowed through it. The domain models were designed around its task-based approach.</p><p name="ac83" id="ac83" class="graf graf--p graf-after--p">WorkflowExecutor was… well, it was thoroughly tested, had its own handlers, and was definitely being maintained. But it wasn’t being used by anything that mattered.</p><p name="715e" id="715e" class="graf graf--p graf-after--p">It was like discovering you’ve been paying rent on two apartments but only sleeping in one.</p><h3 name="2190" id="2190" class="graf graf--h3 graf-after--p">The “why did this happen?” moment</h3><p name="25c0" id="25c0" class="graf graf--p graf-after--h3">Here’s the thing about technical debt: it doesn’t usually happen because you make bad decisions. It happens because you make <em class="markup--em markup--p-em">reasonable</em> decisions that become less reasonable over time, and then you keep making more reasonable decisions on top of them.</p><p name="51e5" id="51e5" class="graf graf--p graf-after--p">WorkflowExecutor started as a perfectly sensible solution for GitHub integration. Quick, focused, got the job done. When we needed file analysis, OrchestrationEngine emerged as a better architectural approach — more extensible, better separation of concerns, aligned with our evolving domain models.</p><p name="cf53" id="cf53" class="graf graf--p graf-after--p">But instead of migrating WorkflowExecutor’s functionality to the new system, we just… kept both. Because WorkflowExecutor was working, and who has time to fix something that isn’t broken when you’re trying to ship features? And, well, I didn’t ask and nobody suggested it.</p><p name="48ce" id="48ce" class="graf graf--p graf-after--p">I was starting to understand how AOL Instant Messenger had gotten into the spaghettified state it was in when I was director of product in its final years.</p><p name="680a" id="680a" class="graf graf--p graf-after--p">Classic technical debt formation: each individual decision makes sense, but the accumulated result is architectural confusion.</p><h3 name="4e64" id="4e64" class="graf graf--h3 graf-after--p">The testing gap that should have been a red flag</h3><p name="72b1" id="72b1" class="graf graf--p graf-after--h3">Here’s what really should have tipped me off: OrchestrationEngine — the system that was actually running our application — had zero tests.</p><p name="f640" id="f640" class="graf graf--p graf-after--p">Zero.</p><p name="65b6" id="65b6" class="graf graf--p graf-after--p">WorkflowExecutor, the legacy system that nothing was using? Comprehensive test coverage.</p><p name="f5a5" id="f5a5" class="graf graf--p graf-after--p">This is like having a perfectly maintained spare car while your daily driver has no brakes. It works right up until you need to stop.</p><p name="d1fe" id="d1fe" class="graf graf--p graf-after--p">The test coverage gap existed because OrchestrationEngine had evolved organically from real usage patterns, while WorkflowExecutor had been built with proper TDD discipline from the start. Good process applied to the wrong system.</p><p name="1c9c" id="1c9c" class="graf graf--p graf-after--p">It’s like we had built a bicycle with state-of-the-art precision and were running our errands in a go-kart.</p><h3 name="6bcf" id="6bcf" class="graf graf--h3 graf-after--p">The hard decision</h3><p name="5dc6" id="5dc6" class="graf graf--p graf-after--h3">When you discover architectural debt like this, you’ve got three options:</p><ol class="postList"><li name="497b" id="497b" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Ignore it</strong>: Keep both systems, accept the confusion, hope future developers figure it out</li><li name="4789" id="4789" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Merge</strong>: Try to combine the best of both systems into some hybrid approach</li><li name="5823" id="5823" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Choose</strong>: Pick the right system and migrate everything to it</li></ol><p name="d3ed" id="d3ed" class="graf graf--p graf-after--li">Option 1 is what got us here in the first place. Option 2 is how you end up with three systems instead of two. That left Option 3.</p><p name="7bf9" id="7bf9" class="graf graf--p graf-after--p">But choosing means admitting that time and effort spent on one system was essentially waste. It means having uncomfortable conversations about sunk costs and technical priorities.</p><p name="2d85" id="2d85" class="graf graf--p graf-after--p">Sometimes the kindest thing you can do for your codebase is stop maintaining the parts that don’t serve it anymore.</p><h3 name="9534" id="9534" class="graf graf--h3 graf-after--p">The OrchestrationEngine decision</h3><p name="f248" id="f248" class="graf graf--p graf-after--h3">So why OrchestrationEngine over WorkflowExecutor?</p><p name="fa1e" id="fa1e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Domain alignment</strong>: OrchestrationEngine’s task-based approach matched how our business logic actually worked. Tasks could be composed, reused, and tested independently.</p><p name="7a87" id="7a87" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Production reality</strong>: It was already handling our most complex workflows successfully. File analysis, user interactions, the stuff that actually mattered — all flowing through OrchestrationEngine.</p><p name="e664" id="e664" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Extension patterns</strong>: Adding new functionality (like GitHub integration) fit naturally into the task handler pattern.</p><p name="8218" id="8218" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Future flexibility</strong>: The architecture anticipated growth in ways WorkflowExecutor didn’t.</p><p name="4b24" id="4b24" class="graf graf--p graf-after--p">WorkflowExecutor wasn’t <em class="markup--em markup--p-em">bad</em> — it was just optimized for a different phase of the project. Early exploration versus systematic growth.</p><h3 name="4119" id="4119" class="graf graf--h3 graf-after--p">The cleanup discipline</h3><p name="9521" id="9521" class="graf graf--p graf-after--h3">Once you make the architectural decision, the cleanup work is mostly mechanical. But it requires discipline.</p><p name="7396" id="7396" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 1</strong>: Ensure the chosen system has proper test coverage (we wrote 11 comprehensive tests for OrchestrationEngine)</p><p name="90b3" id="90b3" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 2</strong>: Extract any unique functionality from the deprecated system (WorkflowExecutor had some GitHub handlers we needed to preserve)</p><p name="6b10" id="6b10" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 3</strong>: Update all documentation to reflect the single-system approach</p><p name="8163" id="8163" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 4</strong>: Actually delete the deprecated code (the hardest step psychologically)</p><p name="f8a1" id="f8a1" class="graf graf--p graf-after--p">The temptation is to just comment out the old system “in case we need it later.” But keeping dead code around is how you end up with technical debt in the first place.</p><p name="077a" id="077a" class="graf graf--p graf-after--p">By the way, this all sounds like I clean up code messes every day. A few weeks earlier I would have despaired of fixing this. I’d have — at best — been trying to follow stepwise advice, showing screens and errors to the chatbot, making typos, breaking stuff. I’d have made a bigger mess. But this far along, trusting the development process we’d, well, developed and was impressed at how smoothly the cleanup went.</p><p name="58aa" id="58aa" class="graf graf--p graf-after--p">So, really, my assistants fix it, but the initial recognition that we had two systems serving the same purpose — that came from forcing myself to slow down and actually understand what we’d built.</p><h3 name="005d" id="005d" class="graf graf--h3 graf-after--p">Documentation-debt déjà vu</h3><p name="b790" id="b790" class="graf graf--p graf-after--h3">Cleaning up the architectural confusion revealed a second layer of debt: our documentation was describing a system that didn’t match what we’d actually built.</p><p name="a4de" id="a4de" class="graf graf--p graf-after--p">The technical specs talked about WorkflowExecutor as the primary orchestration system. The architecture diagrams showed workflows that weren’t actually in use. The API documentation described patterns that had evolved beyond recognition.</p><p name="bc19" id="bc19" class="graf graf--p graf-after--p">This is how technical debt compounds: inconsistent code leads to inconsistent documentation, which leads to incorrect assumptions in future development decisions.</p><p name="079e" id="079e" class="graf graf--p graf-after--p">This happens a lot when you have AIs generate you a bunch of docs as a one-off. Who is going to maintain those docs and keep them up to date? You? Did you even read them? The bots? How will they remember to check, and when? (Over time we solved these problems, but that would be weeks later.)</p><p name="5045" id="5045" class="graf graf--p graf-after--p">And good documentation isn’t just nice to have — it’s a forcing function for architectural clarity.</p><h3 name="21fe" id="21fe" class="graf graf--h3 graf-after--p">What I learned about noticing debt</h3><p name="c404" id="c404" class="graf graf--p graf-after--h3">Technical debt isn’t always obvious. Sometimes it hides in plain sight as “working systems” that just happen to be redundant.</p><p name="b06d" id="b06d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Signals to watch for</strong>:</p><ul class="postList"><li name="355a" id="355a" class="graf graf--li graf-after--p">Developer confusion about which pattern to follow</li><li name="0c25" id="0c25" class="graf graf--li graf-after--li">Multiple ways to accomplish the same fundamental task</li><li name="c4ed" id="c4ed" class="graf graf--li graf-after--li">Test coverage gaps in systems that are actually being used</li><li name="034d" id="034d" class="graf graf--li graf-after--li">Documentation that doesn’t match implementation reality</li><li name="d44a" id="d44a" class="graf graf--li graf-after--li">Integration work that feels harder than it should</li></ul><p name="c779" id="c779" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">The key insight</strong>: Technical debt isn’t just bad code. It’s <em class="markup--em markup--p-em">confusing</em> code. Code that makes the next developer (including future you) have to make decisions that should already be made.</p><h3 name="d7bb" id="d7bb" class="graf graf--h3 graf-after--p">The relief of clarity</h3><p name="181c" id="181c" class="graf graf--p graf-after--h3">There’s something deeply satisfying about resolving architectural confusion. Not just because the codebase is cleaner, but because your mental model finally matches the reality of what you’ve built. It’s like having a headache go away.</p><p name="1ae2" id="1ae2" class="graf graf--p graf-after--p">After the cleanup, adding GitHub integration became straightforward. Create a task handler, register it with OrchestrationEngine, write tests. No decisions about which system to use, no studying two different patterns to figure out which one to follow.</p><p name="77a1" id="77a1" class="graf graf--p graf-after--p">Clarity compounds just like debt does. Every future integration gets easier because the patterns are consistent and well-understood.</p><h3 name="1632" id="1632" class="graf graf--h3 graf-after--p">A systematic approach to debt</h3><p name="7f82" id="7f82" class="graf graf--p graf-after--h3">What turned this from a frustrating discovery into a productive session was approaching it systematically:</p><ol class="postList"><li name="7778" id="7778" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Assess honestly</strong>: What do we actually have, versus what we think we have?</li><li name="1e12" id="1e12" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Trace usage patterns</strong>: Which systems are actually serving users?</li><li name="2e3a" id="2e3a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Evaluate architectural fit</strong>: Which approach serves our long-term goals?</li><li name="f2cc" id="f2cc" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Plan migration</strong>: What needs to be preserved, what can be discarded?</li><li name="1282" id="1282" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Execute with discipline</strong>: Follow through on the cleanup, don’t leave loose ends</li></ol><p name="e918" id="e918" class="graf graf--p graf-after--li">You don’t have to pay off all your debt, certainly not at once. There are acceptable levels of debt at times if it is not slowing you down and not creating compound problems, but other forms of debt cannot be ignored without eventually tanking your project.</p><p name="7f5b" id="7f5b" class="graf graf--p graf-after--p">Technical debt isn’t inherently bad — it’s just the accumulation of decisions that made sense at the time. The problem comes when you stop making conscious choices about it.</p><h3 name="6d2d" id="6d2d" class="graf graf--h3 graf-after--p">More compound effects</h3><p name="804e" id="804e" class="graf graf--p graf-after--h3">The architectural cleanup paid dividends immediately. The next day, when we were working on domain contract enforcement, the clean single-system architecture made it easy to understand where problems were coming from and how to fix them.</p><p name="ed0b" id="ed0b" class="graf graf--p graf-after--p">Later in the week, systematic GitHub integration flowed naturally through the established patterns. No confusion, no competing approaches, just clear implementation following clear architecture.</p><p name="78fa" id="78fa" class="graf graf--p graf-after--p">This is what good technical debt management gets you: not perfect code, but <em class="markup--em markup--p-em">predictable</em> code. Code where the next step is obvious and the patterns are consistent.</p><h3 name="c2fd" id="c2fd" class="graf graf--h3 graf-after--p">When debt becomes opportunity</h3><p name="449a" id="449a" class="graf graf--p graf-after--h3">Here’s what I didn’t expect about the technical debt reckoning: it wasn’t just about cleaning up mistakes. It was about discovering what we’d actually learned about building this kind of system.</p><p name="f584" id="f584" class="graf graf--p graf-after--p">OrchestrationEngine emerged from real usage patterns. It had evolved to solve actual problems we’d encountered with WorkflowExecutor’s approach. The “accidental” architecture was actually better architecture — we just hadn’t recognized it yet.</p><p name="db10" id="db10" class="graf graf--p graf-after--p">Sometimes technical debt isn’t just waste to be cleaned up. It’s evidence of learning that hasn’t been systematized yet.</p><h3 name="d863" id="d863" class="graf graf--h3 graf-after--p">The ongoing discipline</h3><p name="5733" id="5733" class="graf graf--p graf-after--h3">Technical debt management isn’t a one-time cleanup — it’s an ongoing practice. But having gone through this systematic reckoning gave us patterns for recognizing and addressing debt before it compounds.</p><p name="9c44" id="9c44" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Regular architecture reviews</strong>: Periodic check-ins on whether our documented patterns match our implemented patterns</p><p name="de40" id="de40" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Usage audits</strong>: Grep for what’s actually being used versus what’s being maintained</p><p name="dde0" id="dde0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Test coverage monitoring</strong>: Gaps in test coverage often indicate unclear architectural boundaries</p><p name="6866" id="6866" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Developer confusion signals</strong>: When integration work feels harder than it should, that’s usually a debt signal</p><p name="dd92" id="dd92" class="graf graf--p graf-after--p">The goal isn’t to eliminate all technical debt — it’s to make conscious decisions about which debt to accept and which debt to address.</p><h3 name="9bb6" id="9bb6" class="graf graf--h3 graf-after--p">Sunk costs make us feel bad</h3><p name="a138" id="a138" class="graf graf--p graf-after--h3">Maybe the most important lesson from the technical debt reckoning was about honest assessment. It’s easy to rationalize keeping multiple systems because “they both work” or “we might need the flexibility.”</p><p name="2ba5" id="2ba5" class="graf graf--p graf-after--p">But architectural clarity is worth more than theoretical flexibility. Having one well-understood system beats having two sort-of-understood systems, even if both work.</p><p name="21e7" id="21e7" class="graf graf--p graf-after--p">The hardest part wasn’t the technical cleanup — it was admitting that effort spent on WorkflowExecutor was essentially waste, even though every individual decision that led to it was reasonable.</p><p name="53e8" id="53e8" class="graf graf--p graf-after--p graf--trailing">Sometimes the most productive thing you can do is stop being productive in directions that no longer serve the project.</p></div></div></section><section name="3ce4" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="2f9e" id="2f9e" class="graf graf--p graf--leading"><em class="markup--em markup--p-em">Next on Building Piper Morgan “When Your Tests Tell You What Your Code Should Do” — the follow-up story of how clean architecture enables learning.</em></p><p name="6d9f" id="6d9f" class="graf graf--p graf-after--p graf--trailing"><em class="markup--em markup--p-em">What’s your experience with technical debt reckoning? Have you discovered duplicate systems, competing patterns, or architectural confusion hiding in plain sight? I’d love to hear about your own moments of “wait, why do we have two of these?” and how you resolved them.</em></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@mediajunkie" class="p-author h-card">christian crumlish</a> on <a href="https://medium.com/p/160bc294b0b5"><time class="dt-published" datetime="2025-07-28T13:45:50.559Z">July 28, 2025</time></a>.</p><p><a href="https://medium.com/@mediajunkie/the-technical-debt-reckoning-160bc294b0b5" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 9, 2025.</p></footer></article></body></html>