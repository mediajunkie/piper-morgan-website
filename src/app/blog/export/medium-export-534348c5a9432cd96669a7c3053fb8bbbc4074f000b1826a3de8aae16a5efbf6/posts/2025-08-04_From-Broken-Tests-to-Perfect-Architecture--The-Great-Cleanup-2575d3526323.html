<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>From Broken Tests to Perfect Architecture: The Great Cleanup</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">From Broken Tests to Perfect Architecture: The Great Cleanup</h1>
</header>
<section data-field="subtitle" class="p-summary">
July 14
</section>
<section data-field="body" class="e-content">
<section name="58ba" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="4c57" id="4c57" class="graf graf--h3 graf--leading graf--title">From Broken Tests to Perfect Architecture: The Great Cleanup</h3><figure name="94f4" id="94f4" class="graf graf--figure graf--startsWithDoubleQuote graf-after--h3"><img class="graf-image" data-image-id="1*gt2lNbkYQVHRL5JZCpHaNg.png" data-width="1536" data-height="1024" data-is-featured="true" alt="A person and a robot clean up a house that was hit by a hurricane" src="https://cdn-images-1.medium.com/max/800/1*gt2lNbkYQVHRL5JZCpHaNg.png"><figcaption class="imageCaption">“We’ll make it better than new”</figcaption></figure><p name="b43a" id="b43a" class="graf graf--p graf-after--figure"><em class="markup--em markup--p-em">July 14</em></p><p name="9ca2" id="9ca2" class="graf graf--p graf--hasDropCapModel graf--hasDropCap graf-after--p"><span class="graf-dropCap">W</span>hat started as “let’s fix these 9 failing FileRepository tests” became “let’s eliminate three years–worth of accumulated technical debt and achieve 100% architectural pattern compliance.” Sometimes the best debugging sessions are the ones that refuse to stay in their lane.</p><p name="0537" id="0537" class="graf graf--p graf-after--p">(How we accumulated that much tech debt in less than three weeks is another testament to the power of AI.)</p><p name="737f" id="737f" class="graf graf--p graf-after--p">Eventually, we discovered that our test failures weren’t just broken tests — they were symptoms of fundamental architectural inconsistencies that had been lurking beneath a mostly-working system. By the end of a 14-hour session, we’d eliminated dual repository implementations, standardized on consistent patterns, and achieved something every architect dreams of: a codebase where everything follows the same rules.</p><h3 name="752a" id="752a" class="graf graf--h3 graf-after--p">The deceptively simple starting point</h3><p name="1c40" id="1c40" class="graf graf--p graf-after--h3">Fresh off PM-011’s completion and the test suite recovery to 87% pass rate, I thought July 14 would be a cleanup day. Just 27 remaining test failures across a few categories:</p><ul class="postList"><li name="9f78" id="9f78" class="graf graf--li graf-after--p">9 FileRepository tests (connection pool vs session mismatch)</li><li name="f3fd" id="f3fd" class="graf graf--li graf-after--li">3 API query tests (session management issues)</li><li name="265b" id="265b" class="graf graf--li graf-after--li">14 assertion drift tests (float precision, logic updates)</li><li name="43c7" id="43c7" class="graf graf--li graf-after--li">1 miscellaneous test (dataclass issue)</li></ul><p name="54d4" id="54d4" class="graf graf--p graf-after--li">The FileRepository failures looked straightforward: tests were providing AsyncSession objects, but the repository expected connection pools with an <code class="markup--code markup--p-code">.acquire()</code> method. Classic interface mismatch. Should be a quick fix, right?</p><p name="fd00" id="fd00" class="graf graf--p graf-after--p">Famous last words.</p><h3 name="bfdd" id="bfdd" class="graf graf--h3 graf-after--p">The revealing architectural audit</h3><p name="3697" id="3697" class="graf graf--p graf-after--h3">Instead of band-aiding the FileRepository issue, I asked Claude Code to investigate our database patterns more systematically. What came back was a comprehensive architectural compliance audit that revealed uncomfortable truths about our codebase.</p><p name="1a6e" id="1a6e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Repository Compliance: 71% (5/7 repositories)</strong></p><p name="36b0" id="36b0" class="graf graf--p graf-after--p">The audit identified seven repositories across the system:</p><ul class="postList"><li name="e3e9" id="e3e9" class="graf graf--li graf-after--p">✅ 5 repositories fully compliant with our documented Pattern #1</li><li name="ee46" id="ee46" class="graf graf--li graf-after--li">❌ 1 repository using legacy raw SQL + connection pools</li><li name="6800" id="6800" class="graf graf--li graf-after--li">⚠️ 1 repository in the wrong architectural layer</li></ul><p name="4194" id="4194" class="graf graf--p graf-after--li">But the real shock was the footnote: <strong class="markup--strong markup--p-strong">“Dual WorkflowRepository implementation detected.”</strong></p><p name="bb12" id="bb12" class="graf graf--p graf-after--p">We had two completely different WorkflowRepository classes in the codebase. Not variations on a theme — completely different implementations using different patterns, serving different parts of the system. (I was getting déjà vu again. Why did we keep “discovering” that we’d built parallel solutions in the past?)</p><h3 name="b686" id="b686" class="graf graf--h3 graf-after--p">The detective work begins</h3><p name="f321" id="f321" class="graf graf--p graf-after--h3">The FileRepository investigation led to a broader question: how much legacy code were we carrying from before we established architectural patterns?</p><p name="6ae0" id="6ae0" class="graf graf--p graf-after--p">Claude Code’s analysis revealed the scope:</p><p name="0583" id="0583" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Legacy Pattern (Raw SQL + Connection Pools):</strong></p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="2dab" id="2dab" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileRepository</span>:<br />    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, db_pool</span>):<br />        self.db_pool = db_pool<br />    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_file_by_id</span>(<span class="hljs-params">self, file_id: <span class="hljs-built_in">str</span></span>):<br />        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> self.db_pool.acquire() <span class="hljs-keyword">as</span> conn:<br />            row = <span class="hljs-keyword">await</span> conn.fetchrow(<span class="hljs-string">&quot;SELECT * FROM uploaded_files WHERE id = $1&quot;</span>, file_id)</span></pre><p name="5d3a" id="5d3a" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Modern Pattern (SQLAlchemy + Sessions):</strong></p><p name="5182" id="5182" class="graf graf--p graf-after--p">python</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="ruby" name="d2e6" id="d2e6" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileRepository</span>(<span class="hljs-title class_">BaseRepository</span>):<br />    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, <span class="hljs-symbol">session:</span> <span class="hljs-title class_">AsyncSession</span></span>):<br />        <span class="hljs-variable language_">super</span>().__init__(session, <span class="hljs-title class_">UploadedFile</span>DB)<br />    async <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_file_by_id</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, <span class="hljs-symbol">file_id:</span> str</span>) -&gt; <span class="hljs-title class_">Optional</span>[<span class="hljs-title class_">UploadedFile</span>]:<br />        result = await <span class="hljs-variable language_">self</span>.session.execute(<br />            select(<span class="hljs-title class_">UploadedFile</span>DB).where(<span class="hljs-title class_">UploadedFile</span>DB.id == file_id)<br />        )</span></pre><p name="f33f" id="f33f" class="graf graf--p graf-after--pre">The FileRepository was essentially prototype code that had never been migrated to our documented patterns. It worked, but it violated every architectural principle we’d established.</p><p name="3ffc" id="3ffc" class="graf graf--p graf-after--p">Suddenly, I was having nightmares again about the legacy spaghetti that powered AOL Instant Messenger in its final days.</p><h3 name="49b9" id="49b9" class="graf graf--h3 graf-after--p">The dual WorkflowRepository mystery</h3><p name="c9db" id="c9db" class="graf graf--p graf-after--h3">The WorkflowRepository situation was more complex. We had two implementations:</p><p name="e8a1" id="e8a1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Legacy version</strong> (<code class="markup--code markup--p-code">services/repositories/workflow_repository.py</code>):</p><ul class="postList"><li name="5495" id="5495" class="graf graf--li graf-after--p">Raw SQL with connection pools</li><li name="1c59" id="1c59" class="graf graf--li graf-after--li">Used by API endpoints for read operations</li><li name="b4a0" id="b4a0" class="graf graf--li graf-after--li">Methods: <code class="markup--code markup--li-code">find_by_id()</code>, <code class="markup--code markup--li-code">save()</code></li></ul><p name="400b" id="400b" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Modern version</strong> (<code class="markup--code markup--p-code">services/database/repositories.py</code>):</p><ul class="postList"><li name="6fa3" id="6fa3" class="graf graf--li graf-after--p">Inherits from BaseRepository</li><li name="06ee" id="06ee" class="graf graf--li graf-after--li">Used by orchestration engine for write operations</li><li name="7598" id="7598" class="graf graf--li graf-after--li">Methods: <code class="markup--code markup--li-code">create_from_domain()</code>, <code class="markup--code markup--li-code">update_status()</code></li></ul><p name="7c64" id="7c64" class="graf graf--p graf-after--li">The interfaces didn’t even overlap! They were serving completely different use cases, with no obvious conflicts. This explained why the duplication had persisted — each implementation worked perfectly for its specific purpose.</p><p name="f49a" id="f49a" class="graf graf--p graf-after--p">But Claude Code’s investigation revealed the truth: <strong class="markup--strong markup--p-strong">“This is technical debt from an incomplete migration, not an architectural design choice.”</strong></p><p name="2f86" id="2f86" class="graf graf--p graf-after--p">The evidence was clear:</p><ul class="postList"><li name="d3b2" id="d3b2" class="graf graf--li graf-after--p">The orchestration engine had been fully migrated to the RepositoryFactory pattern</li><li name="5657" id="5657" class="graf graf--li graf-after--li">API endpoints had never been migrated from direct imports</li><li name="3656" id="3656" class="graf graf--li graf-after--li">The two repositories existed because the migration was never completed</li></ul><h3 name="46ff" id="46ff" class="graf graf--h3 graf-after--li">The systematic cleanup begins</h3><p name="7c3e" id="7c3e" class="graf graf--p graf-after--h3">Rather than patch around the inconsistencies, we decided to complete the architectural migration properly. The approach: Test-Driven Development for every change, ensuring we didn’t break anything that was working.</p><h4 name="bc8c" id="bc8c" class="graf graf--h4 graf-after--p">Phase 1: FileRepository migration</h4><p name="0134" id="0134" class="graf graf--p graf-after--h4">Claude Code created a comprehensive TDD test suite, then implemented the migration:</p><ul class="postList"><li name="aab5" id="aab5" class="graf graf--li graf-after--p">Migrated from raw SQL to SQLAlchemy ORM</li><li name="3859" id="3859" class="graf graf--li graf-after--li">Changed from connection pools to AsyncSession</li><li name="0165" id="0165" class="graf graf--li graf-after--li">Maintained the same public interface (returns domain models)</li><li name="dd7a" id="dd7a" class="graf graf--li graf-after--li">Followed Pattern #1 from our architecture documentation</li></ul><p name="2894" id="2894" class="graf graf--p graf-after--li">The migration was clean. The repository now inherited from BaseRepository, used standard patterns, and integrated seamlessly with our test infrastructure.</p><h4 name="a823" id="a823" class="graf graf--h4 graf-after--p">Phase 2: WorkflowRepository consolidation</h4><p name="11fa" id="11fa" class="graf graf--p graf-after--h4">This was trickier because we needed to preserve functionality for both use cases:</p><p name="943b" id="943b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 1</strong>: Add missing methods to the modern repository</p><p name="aeb0" id="aeb0" class="graf graf--p graf-after--p">python</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="4871" id="4871" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">async</span> def <span class="hljs-title function_ invoke__">find_by_id</span>(<span class="hljs-keyword">self</span>, workflow_id: <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> Optional[Workflow]:<br />    <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;Add legacy method for API compatibility&quot;</span><span class="hljs-string">&quot;&quot;</span><br />    db_workflow = <span class="hljs-keyword">await</span> <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">get_by_id</span>(workflow_id)<br />    <span class="hljs-keyword">return</span> db_workflow.<span class="hljs-title function_ invoke__">to_domain</span>() <span class="hljs-keyword">if</span> db_workflow <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span></span></pre><p name="e1d0" id="e1d0" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Step 2</strong>: Migrate API endpoints to use RepositoryFactory</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="045e" id="045e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment"># Before: Direct import and connection pool</span><br /><span class="hljs-keyword">from</span> services.repositories.workflow_repository <span class="hljs-keyword">import</span> WorkflowRepository<br />repo = WorkflowRepository(pool)<br /><br /><span class="hljs-comment"># After: Factory pattern with session management</span><br />repos = <span class="hljs-keyword">await</span> RepositoryFactory.get_repositories()<br />db_workflow = <span class="hljs-keyword">await</span> repos[<span class="hljs-string">&quot;workflows&quot;</span>].find_by_id(workflow_id)</span></pre><p name="61c9" id="61c9" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Step 3</strong>: Remove the legacy implementation entirely</p><p name="7953" id="7953" class="graf graf--p graf-after--p">The migration was surgical. API functionality remained identical, but now everything used the same underlying patterns and session management.</p><h3 name="2237" id="2237" class="graf graf--h3 graf-after--p">The async session investigation</h3><p name="9894" id="9894" class="graf graf--p graf-after--h3">With the repository patterns unified, we still had those mysterious “operation in progress” errors in the FileRepository tests. This led to a deep investigation of async session management that revealed important patterns.</p><p name="11b1" id="11b1" class="graf graf--p graf-after--p">The error looked like a concurrency issue:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="csharp" name="09b7" id="09b7" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">sqlalchemy.exc.InterfaceError: cannot perform operation: another operation <span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> progress</span></pre><p name="1a4c" id="1a4c" class="graf graf--p graf-after--pre">But systematic testing revealed the infrastructure was sound. We could run 20 sequential operations without issues. The problem was specific test anti-patterns that were reusing sessions inappropriately.</p><p name="1bc7" id="1bc7" class="graf graf--p graf-after--p">The solution was a session factory pattern for tests:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="csharp" name="295c" id="295c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta"># Anti-pattern: Reusing session in loops</span><br />repo = FileRepository(db_session)<br /><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:<br />    <span class="hljs-keyword">await</span> repo.save_file_metadata(item)  <span class="hljs-meta"># Session reused!</span><br /><br /><span class="hljs-meta"># Better pattern: Fresh session per operation</span><br /><span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">await</span> <span class="hljs-title">db_session_factory</span>() <span class="hljs-keyword">as</span> session:<br />    repo</span> = FileRepository(session)<br />    <span class="hljs-keyword">await</span> repo.save_file_metadata(item)</span></pre><p name="ad58" id="ad58" class="graf graf--p graf-after--pre">This investigation taught us important principles about async database testing and session lifecycle management that will prevent similar issues in the future.</p><h3 name="b8da" id="b8da" class="graf graf--h3 graf-after--p">The moment of architectural victory</h3><p name="a749" id="a749" class="graf graf--p graf-after--h3">By evening, the audit results were transformed:</p><p name="6c57" id="6c57" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Repository Compliance: 100% (7/7 repositories)</strong></p><ul class="postList"><li name="3062" id="3062" class="graf graf--li graf-after--p">✅ All repositories inherit from BaseRepository</li><li name="7abb" id="7abb" class="graf graf--li graf-after--li">✅ All repositories use AsyncSession pattern</li><li name="65b1" id="65b1" class="graf graf--li graf-after--li">✅ All repositories follow documented patterns</li><li name="3347" id="3347" class="graf graf--li graf-after--li">✅ No legacy implementations remaining</li><li name="7b4d" id="7b4d" class="graf graf--li graf-after--li">✅ Consistent architectural layers</li></ul><p name="6e8b" id="6e8b" class="graf graf--p graf-after--li">We’d achieved something rare in software development: complete pattern compliance across the entire system. Every repository now follows the same rules, uses the same base classes, and integrates with the same infrastructure.</p><h3 name="40e8" id="40e8" class="graf graf--h3 graf-after--p">The meta-lessons about technical debt</h3><p name="346a" id="346a" class="graf graf--p graf-after--h3">The July 14 cleanup taught us several important principles:</p><p name="ee29" id="ee29" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Legacy code compounds.</strong> What started as one non-compliant repository revealed systematic architectural inconsistencies. Technical debt doesn’t stay isolated — it spreads and creates maintenance burden across the system.</p><p name="6b9b" id="6b9b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Good architecture makes debugging easier.</strong> Once we had consistent patterns, new issues became obvious. When everything follows the same rules, violations stand out immediately.</p><p name="1a7e" id="1a7e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Test failures can be architectural feedback.</strong> The FileRepository test failures weren’t just broken tests — they were the system telling us about pattern violations we hadn’t noticed.</p><p name="c6de" id="c6de" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">AI agents excel at systematic audits.</strong> Having Claude Code comprehensively audit all repository implementations revealed technical debt we might have missed for months. Different AI agents working in parallel (Cursor on session management, Claude Code on pattern compliance) accelerated the cleanup significantly.</p><h3 name="7d69" id="7d69" class="graf graf--h3 graf-after--p">The collaborative debugging pattern</h3><p name="d360" id="d360" class="graf graf--p graf-after--h3">The session demonstrated an effective pattern for complex architectural work:</p><p name="786b" id="786b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Strategic AI</strong> (Opus) provides oversight and ensures architectural consistency</p><p name="1d78" id="1d78" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Investigative AI</strong> (Claude Code) conducts systematic audits and discovers technical debt</p><p name="462d" id="462d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Implementation AI</strong> (Cursor) executes migrations with TDD discipline</p><p name="41ea" id="41ea" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Human</strong> (that’s me!) makes architectural decisions and coordinates the work</p><p name="bc5c" id="bc5c" class="graf graf--p graf-after--p">This multi-agent approach let us work on different aspects of the same problem simultaneously without conflicts. While Cursor was fixing async session patterns, Claude Code was migrating repository implementations. The parallel work streams accelerated progress significantly.</p><h3 name="b1d9" id="b1d9" class="graf graf--h3 graf-after--p">What this enables going forward</h3><p name="afc8" id="afc8" class="graf graf--p graf-after--h3">Achieving 100% pattern compliance isn’t just aesthetic satisfaction — it has practical benefits:</p><p name="59bc" id="59bc" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Onboarding new developers</strong> becomes easier when everything follows the same patterns. No need to learn multiple ways of doing database access.</p><p name="3500" id="3500" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Adding new repositories</strong> is straightforward — inherit from BaseRepository, follow the established pattern, integrate with RepositoryFactory.</p><p name="d49b" id="d49b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Test infrastructure</strong> works consistently across all components. No special cases or interface mismatches.</p><p name="8b6a" id="8b6a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Debugging database issues</strong> has clear troubleshooting patterns. When everything uses the same session management, problems are easier to isolate.</p><p name="5053" id="5053" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Architectural reviews</strong> can focus on new patterns rather than cleaning up old inconsistencies.</p><h3 name="c173" id="c173" class="graf graf--h3 graf-after--p">The honest assessment</h3><p name="689a" id="689a" class="graf graf--p graf-after--h3">Was the system perfect now? Not even close. We still had test assertion drift, float precision issues, and various edge cases to handle. But the foundational patterns were now solid and consistent.</p><p name="980d" id="980d" class="graf graf--p graf-after--p">Sometimes architectural work feels like “yak shaving” — endlessly preparing to do the real work. But July 14 proved that systematic cleanup creates compound benefits. Every repository that follows consistent patterns is one less maintenance burden. Every eliminated legacy implementation is cognitive overhead removed.</p><h3 name="e3ab" id="e3ab" class="graf graf--h3 graf-after--p">The unexpected satisfaction</h3><p name="1fbf" id="1fbf" class="graf graf--p graf-after--h3">There’s something deeply satisfying about achieving pattern compliance across a complex system. It’s the difference between a codebase that grew organically (with all the inconsistencies that implies) and one that follows coherent principles.</p><p name="ea51" id="ea51" class="graf graf--p graf-after--p">The FileRepository now looks like every other repository. The WorkflowRepository duplication is eliminated. The test infrastructure works consistently. When you open any database-related file, you know exactly what patterns to expect.</p><p name="de3e" id="de3e" class="graf graf--p graf-after--p graf--trailing">That consistency pays dividends every time you need to debug, extend, or modify the system.</p></div></div></section><section name="8172" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="365d" id="365d" class="graf graf--p graf--leading"><em class="markup--em markup--p-em">Next in Building Piper Morgan: When the Pupil Outsmarts the Teacher, or how Piper surprised us by getting too smart for some of our tests.</em></p><p name="08f6" id="08f6" class="graf graf--p graf-after--p graf--trailing"><em class="markup--em markup--p-em">I’d love to hear about times you realized you had to stop working and really clean house if you really wanted to move forward on a solid foundation.</em></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@mediajunkie" class="p-author h-card">christian crumlish</a> on <a href="https://medium.com/p/2575d3526323"><time class="dt-published" datetime="2025-08-04T14:26:31.084Z">August 4, 2025</time></a>.</p><p><a href="https://medium.com/@mediajunkie/from-broken-tests-to-perfect-architecture-the-great-cleanup-2575d3526323" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 9, 2025.</p></footer></article></body></html>