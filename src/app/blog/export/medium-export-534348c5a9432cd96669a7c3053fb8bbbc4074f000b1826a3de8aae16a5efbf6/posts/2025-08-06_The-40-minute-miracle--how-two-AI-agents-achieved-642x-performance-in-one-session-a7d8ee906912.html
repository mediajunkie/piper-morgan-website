<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>The 40-minute miracle: how two AI agents achieved 642x performance in one session</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">The 40-minute miracle: how two AI agents achieved 642x performance in one session</h1>
</header>
<section data-field="subtitle" class="p-summary">
July 18
</section>
<section data-field="body" class="e-content">
<section name="1dd0" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="d0f3" id="d0f3" class="graf graf--h3 graf--leading graf--title">The 40-minute miracle: how two AI agents achieved 642x performance in one session</h3><figure name="bef2" id="bef2" class="graf graf--figure graf--startsWithDoubleQuote graf-after--h3"><img class="graf-image" data-image-id="1*vTNlTUYJowEVdJWs9TS1pg.png" data-width="1536" data-height="1024" data-is-featured="true" alt="A robot passes the baton to another in a relay race" src="https://cdn-images-1.medium.com/max/800/1*vTNlTUYJowEVdJWs9TS1pg.png"><figcaption class="imageCaption">“We’re breaking the record!”</figcaption></figure><p name="0e8c" id="0e8c" class="graf graf--p graf-after--figure"><em class="markup--em markup--p-em">July 18</em></p><p name="d85e" id="d85e" class="graf graf--p graf--hasDropCapModel graf--hasDropCap graf-after--p"><span class="graf-dropCap">H</span>ere’s how you know your development process is getting weird: you deploy two AI agents in parallel, step away for 40 minutes, and come back to a 642ｘ performance improvement with comprehensive documentation.</p><p name="6275" id="6275" class="graf graf--p graf-after--p">I mean, I was <em class="markup--em markup--p-em">present</em> for those 40 minutes. Providing strategic direction, breaking down complex tasks, catching the occasional infinite loop. But the actual coding? That was Claude Code and Cursor Assistant working in perfect coordination while I tried to keep up with their status updates.</p><h3 name="4f79" id="4f79" class="graf graf--h3 graf-after--p">Connection-leak detective work</h3><p name="5ee4" id="5ee4" class="graf graf--p graf-after--h3">Yesterday we’d built domain models for content search in five minutes using TDD. Today’s mission: fix the connection leak from our proof-of-concept that was creating a new connection for every single request.</p><p name="4fc2" id="4fc2" class="graf graf--p graf-after--p">The numbers were damning: 103ms overhead per request just for connection creation. Multiply that by 100 requests and you’re looking at 10+ seconds of pure connection waste.</p><h3 name="2e77" id="2e77" class="graf graf--h3 graf-after--p">The parallel deployment</h3><p name="ff6e" id="ff6e" class="graf graf--p graf-after--h3">Instead of sequential work, I tried something different: deploy both agents simultaneously with clear, non-overlapping assignments.</p><p name="c848" id="c848" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Claude Code</strong>: Build the connection pool with singleton pattern, circuit breaker, and TDD discipline.</p><p name="15a0" id="15a0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Cursor Assistant</strong>: Create performance benchmarks to quantify the problem and validate the solution.</p><p name="6cd6" id="6cd6" class="graf graf--p graf-after--p">The theory was that Code would build the fix while Cursor measured the improvement. In practice, it was like watching a perfectly choreographed dance between two systems that had never worked together before.</p><h3 name="4a61" id="4a61" class="graf graf--h3 graf-after--p">Thesmoking gun</h3><p name="2d76" id="2d76" class="graf graf--p graf-after--h3">Cursor delivered the bad news first: baseline benchmarks showing exactly how broken our POC was.</p><ul class="postList"><li name="0be1" id="0be1" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Connection creation: 103.08ms</strong> per request</li><li name="38bd" id="38bd" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Memory: 18KB</strong> per connection</li><li name="4c64" id="4c64" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Reuse rate: 0%</strong> (new connection every time)</li></ul><p name="fdf1" id="fdf1" class="graf graf--p graf-after--li">Every single request was paying that 103ms tax for the privilege of creating a connection that got thrown away immediately. It was like paying setup fees for every transaction instead of maintaining an account, like getting a new library card every time you want to check out a book.</p><h3 name="a983" id="a983" class="graf graf--h3 graf-after--p">Meanwhile, the async deadlock drama</h3><p name="1a67" id="1a67" class="graf graf--p graf-after--h3">While Cursor was quantifying our connection leak, Code hit a classic async programming challenge: tests hanging on semaphore acquisition. (Yes, I stopped and asked Claude to explain to me what semaphore means in this context — it’s an asyncio concept that allows you to limit the number of simultaneous operations in a section of code).</p><p name="725e" id="725e" class="graf graf--p graf-after--p">The debugging process was fascinating to watch unfold in real-time:</p><ol class="postList"><li name="cb25" id="cb25" class="graf graf--li graf-after--p">Test hangs during pool initialization</li><li name="3fb4" id="3fb4" class="graf graf--li graf-after--li">Investigation reveals lock held during I/O operation</li><li name="9726" id="9726" class="graf graf--li graf-after--li">Breakthrough insight: “Never hold async locks during I/O operations”</li><li name="9c5d" id="9c5d" class="graf graf--li graf-after--li">Refactor to separate state checking from connection creation</li><li name="5d08" id="5d08" class="graf graf--li graf-after--li">All tests pass</li></ol><p name="84aa" id="84aa" class="graf graf--p graf-after--li">That’s the kind of low-level async pattern that can eat hours of debugging time. Code identified and fixed it in about 10 minutes.</p><h3 name="7037" id="7037" class="graf graf--h3 graf-after--p">The integration moment</h3><p name="5615" id="5615" class="graf graf--p graf-after--h3">By 4:50 PM, both agents had completed their assignments:</p><ul class="postList"><li name="d757" id="d757" class="graf graf--li graf-after--p">Code: ✅ Connection pool with 17 comprehensive tests passing</li><li name="c838" id="c838" class="graf graf--li graf-after--li">Cursor: ✅ Performance benchmarks ready to run</li></ul><p name="ea8a" id="ea8a" class="graf graf--p graf-after--li">But there was a gap: the pool wasn’t connected to the benchmarks yet. Code had built beautiful infrastructure, Cursor had perfect measurement tools, but they weren’t talking to each other.</p><p name="68d6" id="68d6" class="graf graf--p graf-after--p">This is where AI coordination gets interesting. Code quickly added a feature flag (<code class="markup--code markup--p-code">USE_MCP_POOL=true/false</code>) for zero-breaking-change integration. Cursor updated the benchmarks to support dual-mode testing. Perfect handoff.</p><p name="ee4d" id="ee4d" class="graf graf--p graf-after--p">I think I first encountered feature flags at CloudOn, where it was critical to be able to ship a feature to the app store turned off, and then turn it on when ready to launch. (We also hid some of our payment features from Apple athat way at 7 Cups but that’s another story.)</p><h3 name="fbb6" id="fbb6" class="graf graf--h3 graf-after--p">The numbers that changed everything</h3><p name="5f17" id="5f17" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">USE_MCP_POOL=false</code> (baseline):</p><ul class="postList"><li name="5dc0" id="5dc0" class="graf graf--li graf-after--p">Connection creation: 102.79ms</li><li name="da6e" id="da6e" class="graf graf--li graf-after--li">Memory per operation: 17.57KB</li><li name="6d92" id="6d92" class="graf graf--li graf-after--li">Connections for 100 requests: 100</li></ul><p name="df95" id="df95" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">USE_MCP_POOL=true</code> (with connection pool):</p><ul class="postList"><li name="8481" id="8481" class="graf graf--li graf-after--p">Connection creation: 0.16ms</li><li name="aa92" id="aa92" class="graf graf--li graf-after--li">Memory per operation: 0.58KB</li><li name="f813" id="f813" class="graf graf--li graf-after--li">Connections for 100 requests: 1 (reused!)</li></ul><p name="4c10" id="4c10" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">642x faster connection creation. 97% memory reduction. 99% fewer connections.</strong></p><p name="33cb" id="33cb" class="graf graf--p graf-after--p">Those aren’t typos. Those are the kind of improvements that change how you think about system architecture. I’ve gotten used to these bots hyping me up. They unintentionally sandbag their estimates by pegging them to human norms, then celebrate when they blow through the estimates, but this is real before-and-after math, a massive reduction in waste.</p><h3 name="d653" id="d653" class="graf graf--h3 graf-after--p">The PM moment</h3><p name="1841" id="1841" class="graf graf--p graf-after--h3">Halfway through the session, Cursor hit a complexity wall trying to create visualization charts for the performance data. The task was getting unwieldy, and I could see the agent starting to struggle.</p><p name="304a" id="304a" class="graf graf--p graf-after--p">This is where the human-in-the-loop pattern becomes crucial: “This assignment may be too challenging. Can we isolate the difficult part?”</p><p name="0492" id="0492" class="graf graf--p graf-after--p">We broke it down: essential documentation (easy), fancy visualizations (nice-to-have). Cursor focused on what mattered, delivered the critical updates, and the session stayed on track.</p><h3 name="ef83" id="ef83" class="graf graf--h3 graf-after--p">The 40-minute reality check</h3><p name="dad4" id="dad4" class="graf graf--p graf-after--h3">At 5:00 PM I looked at the clock and realized something surreal: we’d been actively working for less than 40 minutes.</p><p name="fd90" id="fd90" class="graf graf--p graf-after--p">In those 40 minutes:</p><ul class="postList"><li name="e98a" id="e98a" class="graf graf--li graf-after--p">Identified and quantified a major performance bottleneck</li><li name="1a27" id="1a27" class="graf graf--li graf-after--li">Built production-ready connection pool infrastructure</li><li name="498d" id="498d" class="graf graf--li graf-after--li">Implemented comprehensive error handling and circuit breaker patterns</li><li name="6fd7" id="6fd7" class="graf graf--li graf-after--li">Achieved 642x performance improvement</li><li name="388f" id="388f" class="graf graf--li graf-after--li">Created complete technical documentation</li><li name="0d56" id="0d56" class="graf graf--li graf-after--li">Updated all project tracking</li></ul><p name="ed9c" id="ed9c" class="graf graf--p graf-after--li">The kind of work that would normally take days, compressed into a single focused session.</p><h3 name="e474" id="e474" class="graf graf--h3 graf-after--p">What multi-agent coordination teaches us</h3><p name="3567" id="3567" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">Clear division of labor prevents conflicts.</strong> Code focused on infrastructure, Cursor on measurement. No overlap, no confusion about responsibilities.</p><p name="98c2" id="98c2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Parallel execution multiplies throughput.</strong> Instead of sequential implementation → testing, both happened simultaneously with perfect integration at the end.</p><p name="6629" id="6629" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Feature flags enable safe integration.</strong> Code’s <code class="markup--code markup--p-code">USE_MCP_POOL</code> flag meant zero risk deployment with easy rollback if needed.</p><p name="3e93" id="3e93" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Human coordination amplifies AI capabilities.</strong> The agents were incredibly productive, but needed strategic direction and complexity management to stay effective.</p><h3 name="bc30" id="bc30" class="graf graf--h3 graf-after--p">The deeper insight about performance</h3><p name="09a8" id="09a8" class="graf graf--p graf-after--h3">The 642x improvement wasn’t just about connection pooling — it was about understanding where the real bottlenecks hide. The actual file operations were fast (0.01ms). The content processing was reasonable. But that hidden 103ms connection overhead was eating everything.</p><p name="ab6b" id="ab6b" class="graf graf--p graf-after--p">Performance optimization isn’t about making fast things faster. It’s about finding the thing that’s secretly slow and fixing that first.</p><h3 name="a8d7" id="a8d7" class="graf graf--h3 graf-after--p">What’s next</h3><p name="6b42" id="6b42" class="graf graf--p graf-after--h3">With connection pooling solved, we’re ready for Day 3: real content search. No more fake filename matching — time to implement actual content extraction and TF-IDF relevance scoring using the domain models we built.</p><p name="3e61" id="3e61" class="graf graf--p graf-after--p">The infrastructure foundation is now rock-solid. 642x performance improvement means we can afford to do more sophisticated content analysis without worrying about connection overhead.</p><p name="465c" id="465c" class="graf graf--p graf-after--p graf--trailing">Plus we’ve proven that multi-agent coordination can work beautifully when the division of labor is clear and the integration points are well-defined.</p></div></div></section><section name="6322" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="5f2e" id="5f2e" class="graf graf--p graf--leading"><em class="markup--em markup--p-em">Next on Building Piper Morgan: When Your Infrastructure Gets Smarter Than Your Tests — building content search with MCP and finding out that some test failures are failures of the tests.</em></p><p name="db3f" id="db3f" class="graf graf--p graf-after--p graf--trailing"><em class="markup--em markup--p-em">Ever managed parallel work streams that needed to integrate perfectly at the end? I’m curious how others approach coordination challenges, whether with AI agents or human teams.</em></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@mediajunkie" class="p-author h-card">christian crumlish</a> on <a href="https://medium.com/p/a7d8ee906912"><time class="dt-published" datetime="2025-08-06T12:46:11.621Z">August 6, 2025</time></a>.</p><p><a href="https://medium.com/@mediajunkie/the-40-minute-miracle-how-two-ai-agents-achieved-642x-performance-in-one-session-a7d8ee906912" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 9, 2025.</p></footer></article></body></html>